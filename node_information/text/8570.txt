   [Docs] [txt|pdf] [draft-ietf-tls-...] [Tracker] [Diff1] [Diff2]
   [Errata]
   Updated by: 8446, 8449 PROPOSED STANDARD
   Errata Exist
Internet Engineering Task Force (IETF)                   D. Eastlake 3rd
Request for Comments: 6066                                        Huawei
Obsoletes: 4366                                             January 2011
Category: Standards Track
ISSN: 2070-1721


    Transport Layer Security (TLS) Extensions: Extension Definitions

Abstract

   This document provides specifications for existing TLS extensions.
   It is a companion document for RFC 5246, "The Transport Layer
   Security (TLS) Protocol Version 1.2".  The extensions specified are
   server_name, max_fragment_length, client_certificate_url,
   trusted_ca_keys, truncated_hmac, and status_request.

Status of This Memo

   This is an Internet Standards Track document.

   This document is a product of the Internet Engineering Task Force
   (IETF).  It represents the consensus of the IETF community.  It has
   received public review and has been approved for publication by the
   Internet Engineering Steering Group (IESG).  Further information on
   Internet Standards is available in Section 2 of RFC 5741.

   Information about the current status of this document, any errata,
   and how to provide feedback on it may be obtained at
   http://www.rfc-editor.org/info/rfc6066.

Copyright Notice

   Copyright (c) 2011 IETF Trust and the persons identified as the
   document authors.  All rights reserved.

   This document is subject to BCP 78 and the IETF Trust's Legal
   Provisions Relating to IETF Documents
   (http://trustee.ietf.org/license-info) in effect on the date of
   publication of this document.  Please review these documents
   carefully, as they describe your rights and restrictions with respect
   to this document.  Code Components extracted from this document must
   include Simplified BSD License text as described in Section 4.e of
   the Trust Legal Provisions and are provided without warranty as
   described in the Simplified BSD License.






Eastlake                     Standards Track                    [Page 1]
   __________________________________________________________________


RFC 6066                TLS Extension Definitions           January 2011


   This document may contain material from IETF Documents or IETF
   Contributions published or made publicly available before November
   10, 2008.  The person(s) controlling the copyright in some of this
   material may not have granted the IETF Trust the right to allow
   modifications of such material outside the IETF Standards Process.
   Without obtaining an adequate license from the person(s) controlling
   the copyright in such materials, this document may not be modified
   outside the IETF Standards Process, and derivative works of it may
   not be created outside the IETF Standards Process, except to format
   it for publication as an RFC or to translate it into languages other
   than English.

Table of Contents

   1. Introduction ....................................................3
      1.1. Specific Extensions Covered ................................3
      1.2. Conventions Used in This Document ..........................5
   2. Extensions to the Handshake Protocol ............................5
   3. Server Name Indication ..........................................6
   4. Maximum Fragment Length Negotiation .............................8
   5. Client Certificate URLs .........................................9
   6. Trusted CA Indication ..........................................12
   7. Truncated HMAC .................................................13
   8. Certificate Status Request .....................................14
   9. Error Alerts ...................................................16
   10. IANA Considerations ...........................................17
      10.1. pkipath MIME Type Registration ...........................17
      10.2. Reference for TLS Alerts, TLS HandshakeTypes, and
            ExtensionTypes ...........................................19
   11. Security Considerations .......................................19
      11.1. Security Considerations for server_name ..................19
      11.2. Security Considerations for max_fragment_length ..........20
      11.3. Security Considerations for client_certificate_url .......20
      11.4. Security Considerations for trusted_ca_keys ..............21
      11.5. Security Considerations for truncated_hmac ...............21
      11.6. Security Considerations for status_request ...............22
   12. Normative References ..........................................22
   13. Informative References ........................................23
   Appendix A. Changes from RFC 4366 .................................24
   Appendix B. Acknowledgements ......................................25











Eastlake                     Standards Track                    [Page 2]
   __________________________________________________________________


RFC 6066                TLS Extension Definitions           January 2011


1.  Introduction

   The Transport Layer Security (TLS) Protocol Version 1.2 is specified
   in [RFC5246].  That specification includes the framework for
   extensions to TLS, considerations in designing such extensions (see
   Section 7.4.1.4 of [RFC5246]), and IANA Considerations for the
   allocation of new extension code points; however, it does not specify
   any particular extensions other than Signature Algorithms (see
   Section 7.4.1.4.1 of [RFC5246]).

   This document provides the specifications for existing TLS
   extensions.  It is, for the most part, the adaptation and editing of
   material from RFC 4366, which covered TLS extensions for TLS 1.0 (RFC
   2246) and TLS 1.1 (RFC 4346).

1.1.  Specific Extensions Covered

   The extensions described here focus on extending the functionality
   provided by the TLS protocol message formats.  Other issues, such as
   the addition of new cipher suites, are deferred.

   The extension types defined in this document are:

      enum {
          server_name(0), max_fragment_length(1),
          client_certificate_url(2), trusted_ca_keys(3),
          truncated_hmac(4), status_request(5), (65535)
      } ExtensionType;

   Specifically, the extensions described in this document:

   -  Allow TLS clients to provide to the TLS server the name of the
      server they are contacting.  This functionality is desirable in
      order to facilitate secure connections to servers that host
      multiple 'virtual' servers at a single underlying network address.

   -  Allow TLS clients and servers to negotiate the maximum fragment
      length to be sent.  This functionality is desirable as a result of
      memory constraints among some clients, and bandwidth constraints
      among some access networks.

   -  Allow TLS clients and servers to negotiate the use of client
      certificate URLs.  This functionality is desirable in order to
      conserve memory on constrained clients.







Eastlake                     Standards Track                    [Page 3]
   __________________________________________________________________


RFC 6066                TLS Extension Definitions           January 2011


   -  Allow TLS clients to indicate to TLS servers which certification
      authority (CA) root keys they possess.  This functionality is
      desirable in order to prevent multiple handshake failures
      involving TLS clients that are only able to store a small number
      of CA root keys due to memory limitations.

   -  Allow TLS clients and servers to negotiate the use of truncated
      Message Authentication Codes (MACs).  This functionality is
      desirable in order to conserve bandwidth in constrained access
      networks.

   -  Allow TLS clients and servers to negotiate that the server sends
      the client certificate status information (e.g., an Online
      Certificate Status Protocol (OCSP) [RFC2560] response) during a
      TLS handshake.  This functionality is desirable in order to avoid
      sending a Certificate Revocation List (CRL) over a constrained
      access network and therefore saving bandwidth.

   TLS clients and servers may use the extensions described in this
   document.  The extensions are designed to be backwards compatible,
   meaning that TLS clients that support the extensions can talk to TLS
   servers that do not support the extensions, and vice versa.

   Note that any messages associated with these extensions that are sent
   during the TLS handshake MUST be included in the hash calculations
   involved in "Finished" messages.

   Note also that all the extensions defined in this document are
   relevant only when a session is initiated.  A client that requests
   session resumption does not in general know whether the server will
   accept this request, and therefore it SHOULD send the same extensions
   as it would send if it were not attempting resumption.  When a client
   includes one or more of the defined extension types in an extended
   client hello while requesting session resumption:

   -  The server name indication extension MAY be used by the server
      when deciding whether or not to resume a session as described in
      Section 3.

   -  If the resumption request is denied, the use of the extensions is
      negotiated as normal.

   -  If, on the other hand, the older session is resumed, then the
      server MUST ignore the extensions and send a server hello
      containing none of the extension types.  In this case, the
      functionality of these extensions negotiated during the original
      session initiation is applied to the resumed session.




Eastlake                     Standards Track                    [Page 4]
   __________________________________________________________________


RFC 6066                TLS Extension Definitions           January 2011


1.2.  Conventions Used in This Document

   The key words "MUST", "MUST NOT", "REQUIRED", "SHALL", "SHALL NOT",
   "SHOULD", "SHOULD NOT", "RECOMMENDED", "NOT RECOMMENDED", "MAY", and
   "OPTIONAL" in this document are to be interpreted as described in
   [RFC2119].

2.  Extensions to the Handshake Protocol

   This document specifies the use of two new handshake messages,
   "CertificateURL" and "CertificateStatus".  These messages are
   described in Sections 5 and 8, respectively.  The new handshake
   message structure therefore becomes:

   enum {
       hello_request(0), client_hello(1), server_hello(2),
       certificate(11), server_key_exchange (12),
       certificate_request(13), server_hello_done(14),
       certificate_verify(15), client_key_exchange(16),
       finished(20), certificate_url(21), certificate_status(22),
       (255)
   } HandshakeType;

   struct {
       HandshakeType msg_type;    /* handshake type */
       uint24 length;             /* bytes in message */
       select (HandshakeType) {
           case hello_request:       HelloRequest;
           case client_hello:        ClientHello;
           case server_hello:        ServerHello;
           case certificate:         Certificate;
           case server_key_exchange: ServerKeyExchange;
           case certificate_request: CertificateRequest;
           case server_hello_done:   ServerHelloDone;
           case certificate_verify:  CertificateVerify;
           case client_key_exchange: ClientKeyExchange;
           case finished:            Finished;
           case certificate_url:     CertificateURL;
           case certificate_status:  CertificateStatus;
       } body;
   } Handshake;










Eastlake                     Standards Track                    [Page 5]
   __________________________________________________________________


RFC 6066                TLS Extension Definitions           January 2011


3.  Server Name Indication

   TLS does not provide a mechanism for a client to tell a server the
   name of the server it is contacting.  It may be desirable for clients
   to provide this information to facilitate secure connections to
   servers that host multiple 'virtual' servers at a single underlying
   network address.

   In order to provide any of the server names, clients MAY include an
   extension of type "server_name" in the (extended) client hello.  The
   "extension_data" field of this extension SHALL contain
   "ServerNameList" where:

      struct {
          NameType name_type;
          select (name_type) {
              case host_name: HostName;
          } name;
      } ServerName;

      enum {
          host_name(0), (255)
      } NameType;

      opaque HostName<1..2^16-1>;

      struct {
          ServerName server_name_list<1..2^16-1>
      } ServerNameList;

   The ServerNameList MUST NOT contain more than one name of the same
   name_type.  If the server understood the ClientHello extension but
   does not recognize the server name, the server SHOULD take one of two
   actions: either abort the handshake by sending a fatal-level
   unrecognized_name(112) alert or continue the handshake.  It is NOT
   RECOMMENDED to send a warning-level unrecognized_name(112) alert,
   because the client's behavior in response to warning-level alerts is
   unpredictable.  If there is a mismatch between the server name used
   by the client application and the server name of the credential
   chosen by the server, this mismatch will become apparent when the
   client application performs the server endpoint identification, at
   which point the client application will have to decide whether to
   proceed with the communication.  TLS implementations are encouraged
   to make information available to application callers about warning-
   level alerts that were received or sent during a TLS handshake.  Such
   information can be useful for diagnostic purposes.





Eastlake                     Standards Track                    [Page 6]
   __________________________________________________________________


RFC 6066                TLS Extension Definitions           January 2011


      Note: Earlier versions of this specification permitted multiple
      names of the same name_type.  In practice, current client
      implementations only send one name, and the client cannot
      necessarily find out which name the server selected.  Multiple
      names of the same name_type are therefore now prohibited.

   Currently, the only server names supported are DNS hostnames;
   however, this does not imply any dependency of TLS on DNS, and other
   name types may be added in the future (by an RFC that updates this
   document).  The data structure associated with the host_name NameType
   is a variable-length vector that begins with a 16-bit length.  For
   backward compatibility, all future data structures associated with
   new NameTypes MUST begin with a 16-bit length field.  TLS MAY treat
   provided server names as opaque data and pass the names and types to
   the application.

   "HostName" contains the fully qualified DNS hostname of the server,
   as understood by the client.  The hostname is represented as a byte
   string using ASCII encoding without a trailing dot.  This allows the
   support of internationalized domain names through the use of A-labels
   defined in [RFC5890].  DNS hostnames are case-insensitive.  The
   algorithm to compare hostnames is described in [RFC5890], Section
   2.3.2.4.

   Literal IPv4 and IPv6 addresses are not permitted in "HostName".

   It is RECOMMENDED that clients include an extension of type
   "server_name" in the client hello whenever they locate a server by a
   supported name type.

   A server that receives a client hello containing the "server_name"
   extension MAY use the information contained in the extension to guide
   its selection of an appropriate certificate to return to the client,
   and/or other aspects of security policy.  In this event, the server
   SHALL include an extension of type "server_name" in the (extended)
   server hello.  The "extension_data" field of this extension SHALL be
   empty.

   When the server is deciding whether or not to accept a request to
   resume a session, the contents of a server_name extension MAY be used
   in the lookup of the session in the session cache.  The client SHOULD
   include the same server_name extension in the session resumption
   request as it did in the full handshake that established the session.
   A server that implements this extension MUST NOT accept the request
   to resume the session if the server_name extension contains a
   different name.  Instead, it proceeds with a full handshake to
   establish a new session.  When resuming a session, the server MUST
   NOT include a server_name extension in the server hello.



Eastlake                     Standards Track                    [Page 7]
   __________________________________________________________________


RFC 6066                TLS Extension Definitions           January 2011


   If an application negotiates a server name using an application
   protocol and then upgrades to TLS, and if a server_name extension is
   sent, then the extension SHOULD contain the same name that was
   negotiated in the application protocol.  If the server_name is
   established in the TLS session handshake, the client SHOULD NOT
   attempt to request a different server name at the application layer.

4.  Maximum Fragment Length Negotiation

   Without this extension, TLS specifies a fixed maximum plaintext
   fragment length of 2^14 bytes.  It may be desirable for constrained
   clients to negotiate a smaller maximum fragment length due to memory
   limitations or bandwidth limitations.

   In order to negotiate smaller maximum fragment lengths, clients MAY
   include an extension of type "max_fragment_length" in the (extended)
   client hello.  The "extension_data" field of this extension SHALL
   contain:

      enum{
          2^9(1), 2^10(2), 2^11(3), 2^12(4), (255)
      } MaxFragmentLength;

   whose value is the desired maximum fragment length.  The allowed
   values for this field are: 2^9, 2^10, 2^11, and 2^12.

   Servers that receive an extended client hello containing a
   "max_fragment_length" extension MAY accept the requested maximum
   fragment length by including an extension of type
   "max_fragment_length" in the (extended) server hello.  The
   "extension_data" field of this extension SHALL contain a
   "MaxFragmentLength" whose value is the same as the requested maximum
   fragment length.

   If a server receives a maximum fragment length negotiation request
   for a value other than the allowed values, it MUST abort the
   handshake with an "illegal_parameter" alert.  Similarly, if a client
   receives a maximum fragment length negotiation response that differs
   from the length it requested, it MUST also abort the handshake with
   an "illegal_parameter" alert.

   Once a maximum fragment length other than 2^14 has been successfully
   negotiated, the client and server MUST immediately begin fragmenting
   messages (including handshake messages) to ensure that no fragment
   larger than the negotiated length is sent.  Note that TLS already
   requires clients and servers to support fragmentation of handshake
   messages.




Eastlake                     Standards Track                    [Page 8]
   __________________________________________________________________


RFC 6066                TLS Extension Definitions           January 2011


   The negotiated length applies for the duration of the session
   including session resumptions.

   The negotiated length limits the input that the record layer may
   process without fragmentation (that is, the maximum value of
   TLSPlaintext.length; see [RFC5246], Section 6.2.1).  Note that the
   output of the record layer may be larger.  For example, if the
   negotiated length is 2^9=512, then, when using currently defined
   cipher suites (those defined in [RFC5246] and [RFC2712]) and null
   compression, the record-layer output can be at most 805 bytes: 5
   bytes of headers, 512 bytes of application data, 256 bytes of
   padding, and 32 bytes of MAC.  This means that in this event a TLS
   record-layer peer receiving a TLS record-layer message larger than
   805 bytes MUST discard the message and send a "record_overflow"
   alert, without decrypting the message.  When this extension is used
   with Datagram Transport Layer Security (DTLS), implementations SHOULD
   NOT generate record_overflow alerts unless the packet passes message
   authentication.

5.  Client Certificate URLs

   Without this extension, TLS specifies that when client authentication
   is performed, client certificates are sent by clients to servers
   during the TLS handshake.  It may be desirable for constrained
   clients to send certificate URLs in place of certificates, so that
   they do not need to store their certificates and can therefore save
   memory.

   In order to negotiate sending certificate URLs to a server, clients
   MAY include an extension of type "client_certificate_url" in the
   (extended) client hello.  The "extension_data" field of this
   extension SHALL be empty.

   (Note that it is necessary to negotiate the use of client certificate
   URLs in order to avoid "breaking" existing TLS servers.)

   Servers that receive an extended client hello containing a
   "client_certificate_url" extension MAY indicate that they are willing
   to accept certificate URLs by including an extension of type
   "client_certificate_url" in the (extended) server hello.  The
   "extension_data" field of this extension SHALL be empty.

   After negotiation of the use of client certificate URLs has been
   successfully completed (by exchanging hellos including
   "client_certificate_url" extensions), clients MAY send a
   "CertificateURL" message in place of a "Certificate" message as
   follows (see also Section 2):




Eastlake                     Standards Track                    [Page 9]
   __________________________________________________________________


RFC 6066                TLS Extension Definitions           January 2011


      enum {
          individual_certs(0), pkipath(1), (255)
      } CertChainType;

      struct {
          CertChainType type;
          URLAndHash url_and_hash_list<1..2^16-1>;
      } CertificateURL;

      struct {
          opaque url<1..2^16-1>;
          unint8 padding;
          opaque SHA1Hash[20];
      } URLAndHash;

   Here, "url_and_hash_list" contains a sequence of URLs and hashes.
   Each "url" MUST be an absolute URI reference according to [RFC3986]
   that can be immediately used to fetch the certificate(s).

   When X.509 certificates are used, there are two possibilities:

   -  If CertificateURL.type is "individual_certs", each URL refers to a
      single DER-encoded X.509v3 certificate, with the URL for the
      client's certificate first.

   -  If CertificateURL.type is "pkipath", the list contains a single
      URL referring to a DER-encoded certificate chain, using the type
      PkiPath described in Section 10.1.

   When any other certificate format is used, the specification that
   describes use of that format in TLS should define the encoding format
   of certificates or certificate chains, and any constraint on their
   ordering.

   The "padding" byte MUST be 0x01.  It is present to make the structure
   backwards compatible.

   The hash corresponding to each URL is the SHA-1 hash of the
   certificate or certificate chain (in the case of X.509 certificates,
   the DER-encoded certificate or the DER-encoded PkiPath).

   Note that when a list of URLs for X.509 certificates is used, the
   ordering of URLs is the same as that used in the TLS Certificate
   message (see [RFC5246], Section 7.4.2), but opposite to the order in
   which certificates are encoded in PkiPath.  In either case, the self-
   signed root certificate MAY be omitted from the chain, under the
   assumption that the server must already possess it in order to
   validate it.



Eastlake                     Standards Track                   [Page 10]
   __________________________________________________________________


RFC 6066                TLS Extension Definitions           January 2011


   Servers receiving "CertificateURL" SHALL attempt to retrieve the
   client's certificate chain from the URLs and then process the
   certificate chain as usual.  A cached copy of the content of any URL
   in the chain MAY be used, provided that the SHA-1 hash matches the
   hash of the cached copy.

   Servers that support this extension MUST support the 'http' URI
   scheme for certificate URLs and MAY support other schemes.  Use of
   other schemes than 'http', 'https', or 'ftp' may create unexpected
   problems.

   If the protocol used is HTTP, then the HTTP server can be configured
   to use the Cache-Control and Expires directives described in
   [RFC2616] to specify whether and for how long certificates or
   certificate chains should be cached.

   The TLS server MUST NOT follow HTTP redirects when retrieving the
   certificates or certificate chain.  The URLs used in this extension
   MUST NOT be chosen to depend on such redirects.

   If the protocol used to retrieve certificates or certificate chains
   returns a MIME-formatted response (as HTTP does), then the following
   MIME Content-Types SHALL be used: when a single X.509v3 certificate
   is returned, the Content-Type is "application/pkix-cert" [RFC2585],
   and when a chain of X.509v3 certificates is returned, the Content-
   Type is "application/pkix-pkipath" (Section 10.1).

   The server MUST check that the SHA-1 hash of the contents of the
   object retrieved from that URL (after decoding any MIME Content-
   Transfer-Encoding) matches the given hash.  If any retrieved object
   does not have the correct SHA-1 hash, the server MUST abort the
   handshake with a bad_certificate_hash_value(114) alert.  This alert
   is always fatal.

   Clients may choose to send either "Certificate" or "CertificateURL"
   after successfully negotiating the option to send certificate URLs.
   The option to send a certificate is included to provide flexibility
   to clients possessing multiple certificates.

   If a server is unable to obtain certificates in a given
   CertificateURL, it MUST send a fatal certificate_unobtainable(111)
   alert if it requires the certificates to complete the handshake.  If
   the server does not require the certificates, then the server
   continues the handshake.  The server MAY send a warning-level alert
   in this case.  Clients receiving such an alert SHOULD log the alert
   and continue with the handshake if possible.





Eastlake                     Standards Track                   [Page 11]
   __________________________________________________________________


RFC 6066                TLS Extension Definitions           January 2011


6.  Trusted CA Indication

   Constrained clients that, due to memory limitations, possess only a
   small number of CA root keys may wish to indicate to servers which
   root keys they possess, in order to avoid repeated handshake
   failures.

   In order to indicate which CA root keys they possess, clients MAY
   include an extension of type "trusted_ca_keys" in the (extended)
   client hello.  The "extension_data" field of this extension SHALL
   contain "TrustedAuthorities" where:

      struct {
          TrustedAuthority trusted_authorities_list<0..2^16-1>;
      } TrustedAuthorities;

      struct {
          IdentifierType identifier_type;
          select (identifier_type) {
              case pre_agreed: struct {};
              case key_sha1_hash: SHA1Hash;
              case x509_name: DistinguishedName;
              case cert_sha1_hash: SHA1Hash;
          } identifier;
      } TrustedAuthority;

      enum {
          pre_agreed(0), key_sha1_hash(1), x509_name(2),
          cert_sha1_hash(3), (255)
      } IdentifierType;

      opaque DistinguishedName<1..2^16-1>;

   Here, "TrustedAuthorities" provides a list of CA root key identifiers
   that the client possesses.  Each CA root key is identified via
   either:

   -  "pre_agreed": no CA root key identity supplied.

   -  "key_sha1_hash": contains the SHA-1 hash of the CA root key.  For
      Digital Signature Algorithm (DSA) and Elliptic Curve Digital
      Signature Algorithm (ECDSA) keys, this is the hash of the
      "subjectPublicKey" value.  For RSA keys, the hash is of the big-
      endian byte string representation of the modulus without any
      initial zero-valued bytes.  (This copies the key hash formats
      deployed in other environments.)





Eastlake                     Standards Track                   [Page 12]
   __________________________________________________________________


RFC 6066                TLS Extension Definitions           January 2011


   -  "x509_name": contains the DER-encoded X.509 DistinguishedName of
      the CA.

   -  "cert_sha1_hash": contains the SHA-1 hash of a DER-encoded
      Certificate containing the CA root key.

   Note that clients may include none, some, or all of the CA root keys
   they possess in this extension.

   Note also that it is possible that a key hash or a Distinguished Name
   alone may not uniquely identify a certificate issuer (for example, if
   a particular CA has multiple key pairs).  However, here we assume
   this is the case following the use of Distinguished Names to identify
   certificate issuers in TLS.

   The option to include no CA root keys is included to allow the client
   to indicate possession of some pre-defined set of CA root keys.

   Servers that receive a client hello containing the "trusted_ca_keys"
   extension MAY use the information contained in the extension to guide
   their selection of an appropriate certificate chain to return to the
   client.  In this event, the server SHALL include an extension of type
   "trusted_ca_keys" in the (extended) server hello.  The
   "extension_data" field of this extension SHALL be empty.

7.  Truncated HMAC

   Currently defined TLS cipher suites use the MAC construction HMAC
   [RFC2104] to authenticate record-layer communications.  In TLS, the
   entire output of the hash function is used as the MAC tag.  However,
   it may be desirable in constrained environments to save bandwidth by
   truncating the output of the hash function to 80 bits when forming
   MAC tags.

   In order to negotiate the use of 80-bit truncated HMAC, clients MAY
   include an extension of type "truncated_hmac" in the extended client
   hello.  The "extension_data" field of this extension SHALL be empty.

   Servers that receive an extended hello containing a "truncated_hmac"
   extension MAY agree to use a truncated HMAC by including an extension
   of type "truncated_hmac", with empty "extension_data", in the
   extended server hello.

   Note that if new cipher suites are added that do not use HMAC, and
   the session negotiates one of these cipher suites, this extension
   will have no effect.  It is strongly recommended that any new cipher
   suites using other MACs consider the MAC size an integral part of the




Eastlake                     Standards Track                   [Page 13]
   __________________________________________________________________


RFC 6066                TLS Extension Definitions           January 2011


   cipher suite definition, taking into account both security and
   bandwidth considerations.

   If HMAC truncation has been successfully negotiated during a TLS
   handshake, and the negotiated cipher suite uses HMAC, both the client
   and the server pass this fact to the TLS record layer along with the
   other negotiated security parameters.  Subsequently during the
   session, clients and servers MUST use truncated HMACs, calculated as
   specified in [RFC2104].  That is, SecurityParameters.mac_length is 10
   bytes, and only the first 10 bytes of the HMAC output are transmitted
   and checked.  Note that this extension does not affect the
   calculation of the pseudo-random function (PRF) as part of
   handshaking or key derivation.

   The negotiated HMAC truncation size applies for the duration of the
   session including session resumptions.

8.  Certificate Status Request

   Constrained clients may wish to use a certificate-status protocol
   such as OCSP [RFC2560] to check the validity of server certificates,
   in order to avoid transmission of CRLs and therefore save bandwidth
   on constrained networks.  This extension allows for such information
   to be sent in the TLS handshake, saving roundtrips and resources.

   In order to indicate their desire to receive certificate status
   information, clients MAY include an extension of type
   "status_request" in the (extended) client hello.  The
   "extension_data" field of this extension SHALL contain
   "CertificateStatusRequest" where:

      struct {
          CertificateStatusType status_type;
          select (status_type) {
              case ocsp: OCSPStatusRequest;
          } request;
      } CertificateStatusRequest;

      enum { ocsp(1), (255) } CertificateStatusType;

      struct {
          ResponderID responder_id_list<0..2^16-1>;
          Extensions  request_extensions;
      } OCSPStatusRequest;

      opaque ResponderID<1..2^16-1>;
      opaque Extensions<0..2^16-1>;




Eastlake                     Standards Track                   [Page 14]
   __________________________________________________________________


RFC 6066                TLS Extension Definitions           January 2011


   In the OCSPStatusRequest, the "ResponderIDs" provides a list of OCSP
   responders that the client trusts.  A zero-length "responder_id_list"
   sequence has the special meaning that the responders are implicitly
   known to the server, e.g., by prior arrangement.  "Extensions" is a
   DER encoding of OCSP request extensions.

   Both "ResponderID" and "Extensions" are DER-encoded ASN.1 types as
   defined in [RFC2560].  "Extensions" is imported from [RFC5280].  A
   zero-length "request_extensions" value means that there are no
   extensions (as opposed to a zero-length ASN.1 SEQUENCE, which is not
   valid for the "Extensions" type).

   In the case of the "id-pkix-ocsp-nonce" OCSP extension, [RFC2560] is
   unclear about its encoding; for clarification, the nonce MUST be a
   DER-encoded OCTET STRING, which is encapsulated as another OCTET
   STRING (note that implementations based on an existing OCSP client
   will need to be checked for conformance to this requirement).

   Servers that receive a client hello containing the "status_request"
   extension MAY return a suitable certificate status response to the
   client along with their certificate.  If OCSP is requested, they
   SHOULD use the information contained in the extension when selecting
   an OCSP responder and SHOULD include request_extensions in the OCSP
   request.

   Servers return a certificate response along with their certificate by
   sending a "CertificateStatus" message immediately after the
   "Certificate" message (and before any "ServerKeyExchange" or
   "CertificateRequest" messages).  If a server returns a
   "CertificateStatus" message, then the server MUST have included an
   extension of type "status_request" with empty "extension_data" in the
   extended server hello.  The "CertificateStatus" message is conveyed
   using the handshake message type "certificate_status" as follows (see
   also Section 2):

      struct {
          CertificateStatusType status_type;
          select (status_type) {
              case ocsp: OCSPResponse;
          } response;
      } CertificateStatus;

      opaque OCSPResponse<1..2^24-1>;

   An "ocsp_response" contains a complete, DER-encoded OCSP response
   (using the ASN.1 type OCSPResponse defined in [RFC2560]).  Only one
   OCSP response may be sent.




Eastlake                     Standards Track                   [Page 15]
   __________________________________________________________________


RFC 6066                TLS Extension Definitions           January 2011


   Note that a server MAY also choose not to send a "CertificateStatus"
   message, even if has received a "status_request" extension in the
   client hello message and has sent a "status_request" extension in the
   server hello message.

   Note in addition that a server MUST NOT send the "CertificateStatus"
   message unless it received a "status_request" extension in the client
   hello message and sent a "status_request" extension in the server
   hello message.

   Clients requesting an OCSP response and receiving an OCSP response in
   a "CertificateStatus" message MUST check the OCSP response and abort
   the handshake if the response is not satisfactory with
   bad_certificate_status_response(113) alert.  This alert is always
   fatal.

9.  Error Alerts

   Four new error alerts are defined for use with the TLS extensions
   defined in this document.  To avoid "breaking" existing clients and
   servers, these alerts MUST NOT be sent unless the sending party has
   received an extended hello message from the party they are
   communicating with.  These error alerts are conveyed using the
   following syntax.  The new alerts are the last four, as indicated by
   the comments on the same line as the error alert number.

      enum {
          close_notify(0),
          unexpected_message(10),
          bad_record_mac(20),
          decryption_failed(21),
          record_overflow(22),
          decompression_failure(30),
          handshake_failure(40),
          /* 41 is not defined, for historical reasons */
          bad_certificate(42),
          unsupported_certificate(43),
          certificate_revoked(44),
          certificate_expired(45),
          certificate_unknown(46),
          illegal_parameter(47),
          unknown_ca(48),
          access_denied(49),
          decode_error(50),
          decrypt_error(51),
          export_restriction(60),
          protocol_version(70),
          insufficient_security(71),



Eastlake                     Standards Track                   [Page 16]
   __________________________________________________________________


RFC 6066                TLS Extension Definitions           January 2011


          internal_error(80),
          user_canceled(90),
          no_renegotiation(100),
          unsupported_extension(110),
          certificate_unobtainable(111),        /* new */
          unrecognized_name(112),               /* new */
          bad_certificate_status_response(113), /* new */
          bad_certificate_hash_value(114),      /* new */
          (255)
      } AlertDescription;

   "certificate_unobtainable" is described in Section 5.
   "unrecognized_name" is described in Section 3.
   "bad_certificate_status_response" is described in Section 8.
   "bad_certificate_hash_value" is described in Section 5.

10.  IANA Considerations

   IANA Considerations for TLS extensions and the creation of a registry
   are covered in Section 12 of [RFC5246] except for the registration of
   MIME type application/pkix-pkipath, which appears below.

   The IANA TLS extensions and MIME type application/pkix-pkipath
   registry entries that reference RFC 4366 have been updated to
   reference this document.

10.1.  pkipath MIME Type Registration

   MIME media type name: application
   MIME subtype name: pkix-pkipath
   Required parameters: none

   Optional parameters: version (default value is "1")

   Encoding considerations:
      Binary; this MIME type is a DER encoding of the ASN.1 type
      PkiPath, defined as follows:
        PkiPath ::= SEQUENCE OF Certificate
        PkiPath is used to represent a certification path.  Within the
        sequence, the order of certificates is such that the subject of
        the first certificate is the issuer of the second certificate,
        etc.
      This is identical to the definition published in [X509-4th-TC1];
      note that it is different from that in [X509-4th].

      All Certificates MUST conform to [RFC5280].  (This should be
      interpreted as a requirement to encode only PKIX-conformant
      certificates using this type.  It does not necessarily require



Eastlake                     Standards Track                   [Page 17]
   __________________________________________________________________


RFC 6066                TLS Extension Definitions           January 2011


      that all certificates that are not strictly PKIX-conformant must
      be rejected by relying parties, although the security consequences
      of accepting any such certificates should be considered
      carefully.)

      DER (as opposed to BER) encoding MUST be used.  If this type is
      sent over a 7-bit transport, base64 encoding SHOULD be used.

   Security considerations:
      The security considerations of [X509-4th] and [RFC5280] (or any
      updates to them) apply, as well as those of any protocol that uses
      this type (e.g., TLS).

      Note that this type only specifies a certificate chain that can be
      assessed for validity according to the relying party's existing
      configuration of trusted CAs; it is not intended to be used to
      specify any change to that configuration.

   Interoperability considerations:
      No specific interoperability problems are known with this type,
      but for recommendations relating to X.509 certificates in general,
      see [RFC5280].

   Published specification: This document and [RFC5280].

   Applications that use this media type:
      TLS.  It may also be used by other protocols or for general
      interchange of PKIX certificate chains.

   Additional information:
      Magic number(s): DER-encoded ASN.1 can be easily recognized.
        Further parsing is required to distinguish it from other ASN.1
        types.
      File extension(s): .pkipath
      Macintosh File Type Code(s): not specified

   Person & email address to contact for further information:
      Magnus Nystrom <mnystrom@microsoft.com>

   Intended usage: COMMON

   Change controller: IESG <iesg@ietf.org>









Eastlake                     Standards Track                   [Page 18]
   __________________________________________________________________


RFC 6066                TLS Extension Definitions           January 2011


10.2.  Reference for TLS Alerts, TLS HandshakeTypes, and ExtensionTypes

   The following values in the TLS Alert Registry have been updated to
   reference this document:

      111 certificate_unobtainable
      112 unrecognized_name
      113 bad_certificate_status_response
      114 bad_certificate_hash_value

   The following values in the TLS HandshakeType Registry have been
   updated to reference this document:

      21 certificate_url
      22 certificate_status

   The following ExtensionType values have been updated to reference
   this document:

      0 server_name
      1 max_fragment_length
      2 client_certificate_url
      3 trusted_ca_keys
      4 truncated_hmac
      5 status_request

11.  Security Considerations

   General security considerations for TLS extensions are covered in
   [RFC5246].  Security Considerations for particular extensions
   specified in this document are given below.

   In general, implementers should continue to monitor the state of the
   art and address any weaknesses identified.

11.1.  Security Considerations for server_name

   If a single server hosts several domains, then clearly it is
   necessary for the owners of each domain to ensure that this satisfies
   their security needs.  Apart from this, server_name does not appear
   to introduce significant security issues.

   Since it is possible for a client to present a different server_name
   in the application protocol, application server implementations that
   rely upon these names being the same MUST check to make sure the
   client did not present a different name in the application protocol.





Eastlake                     Standards Track                   [Page 19]
   __________________________________________________________________


RFC 6066                TLS Extension Definitions           January 2011


   Implementations MUST ensure that a buffer overflow does not occur,
   whatever the values of the length fields in server_name.

11.2.  Security Considerations for max_fragment_length

   The maximum fragment length takes effect immediately, including for
   handshake messages.  However, that does not introduce any security
   complications that are not already present in TLS, since TLS requires
   implementations to be able to handle fragmented handshake messages.

   Note that, as described in Section 4, once a non-null cipher suite
   has been activated, the effective maximum fragment length depends on
   the cipher suite and compression method, as well as on the negotiated
   max_fragment_length.  This must be taken into account when sizing
   buffers and checking for buffer overflow.

11.3.  Security Considerations for client_certificate_url

   Support for client_certificate_url involves the server's acting as a
   client in another URI-scheme-dependent protocol.  The server
   therefore becomes subject to many of the same security concerns that
   clients of the URI scheme are subject to, with the added concern that
   the client can attempt to prompt the server to connect to some
   (possibly weird-looking) URL.

   In general, this issue means that an attacker might use the server to
   indirectly attack another host that is vulnerable to some security
   flaw.  It also introduces the possibility of denial-of-service
   attacks in which an attacker makes many connections to the server,
   each of which results in the server's attempting a connection to the
   target of the attack.

   Note that the server may be behind a firewall or otherwise able to
   access hosts that would not be directly accessible from the public
   Internet.  This could exacerbate the potential security and denial-
   of-service problems described above, as well as allow the existence
   of internal hosts to be confirmed when they would otherwise be
   hidden.

   The detailed security concerns involved will depend on the URI
   schemes supported by the server.  In the case of HTTP, the concerns
   are similar to those that apply to a publicly accessible HTTP proxy
   server.  In the case of HTTPS, loops and deadlocks may be created,
   and this should be addressed.  In the case of FTP, attacks arise that
   are similar to FTP bounce attacks.






Eastlake                     Standards Track                   [Page 20]
   __________________________________________________________________


RFC 6066                TLS Extension Definitions           January 2011


   As a result of this issue, it is RECOMMENDED that the
   client_certificate_url extension should have to be specifically
   enabled by a server administrator, rather than be enabled by default.
   It is also RECOMMENDED that URI schemes be enabled by the
   administrator individually, and only a minimal set of schemes be
   enabled.  Unusual protocols that offer limited security or whose
   security is not well understood SHOULD be avoided.

   As discussed in [RFC3986], URLs that specify ports other than the
   default may cause problems, as may very long URLs (which are more
   likely to be useful in exploiting buffer overflow bugs).

   This extension continues to use SHA-1 (as in RFC 4366) and does not
   provide algorithm agility.  The property required of SHA-1 in this
   case is second pre-image resistance, not collision resistance.
   Furthermore, even if second pre-image attacks against SHA-1 are found
   in the future, an attack against client_certificate_url would require
   a second pre-image that is accepted as a valid certificate by the
   server and contains the same public key.

   Also note that HTTP caching proxies are common on the Internet, and
   some proxies do not check for the latest version of an object
   correctly.  If a request using HTTP (or another caching protocol)
   goes through a misconfigured or otherwise broken proxy, the proxy may
   return an out-of-date response.

11.4.  Security Considerations for trusted_ca_keys

   Potentially, the CA root keys a client possesses could be regarded as
   confidential information.  As a result, the CA root key indication
   extension should be used with care.

   The use of the SHA-1 certificate hash alternative ensures that each
   certificate is specified unambiguously.  This context does not
   require a cryptographic hash function, so the use of SHA-1 is
   considered acceptable, and no algorithm agility is provided.

11.5.  Security Considerations for truncated_hmac

   It is possible that truncated MACs are weaker than "un-truncated"
   MACs.  However, no significant weaknesses are currently known or
   expected to exist for HMAC with MD5 or SHA-1, truncated to 80 bits.

   Note that the output length of a MAC need not be as long as the
   length of a symmetric cipher key, since forging of MAC values cannot
   be done off-line: in TLS, a single failed MAC guess will cause the
   immediate termination of the TLS session.




Eastlake                     Standards Track                   [Page 21]
   __________________________________________________________________


RFC 6066                TLS Extension Definitions           January 2011


   Since the MAC algorithm only takes effect after all handshake
   messages that affect extension parameters have been authenticated by
   the hashes in the Finished messages, it is not possible for an active
   attacker to force negotiation of the truncated HMAC extension where
   it would not otherwise be used (to the extent that the handshake
   authentication is secure).  Therefore, in the event that any security
   problems were found with truncated HMAC in the future, if either the
   client or the server for a given session were updated to take the
   problem into account, it would be able to veto use of this extension.

11.6.  Security Considerations for status_request

   If a client requests an OCSP response, it must take into account that
   an attacker's server using a compromised key could (and probably
   would) pretend not to support the extension.  In this case, a client
   that requires OCSP validation of certificates SHOULD either contact
   the OCSP server directly or abort the handshake.

   Use of the OCSP nonce request extension (id-pkix-ocsp-nonce) may
   improve security against attacks that attempt to replay OCSP
   responses; see Section 4.4.1 of [RFC2560] for further details.

12.  Normative References

   [RFC2104]      Krawczyk, H., Bellare, M., and R. Canetti, "HMAC:
                  Keyed-Hashing for Message Authentication", RFC 2104,
                  February 1997.

   [RFC2119]      Bradner, S., "Key words for use in RFCs to Indicate
                  Requirement Levels", BCP 14, RFC 2119, March 1997.

   [RFC2560]      Myers, M., Ankney, R., Malpani, A., Galperin, S., and
                  C. Adams, "X.509 Internet Public Key Infrastructure
                  Online Certificate Status Protocol - OCSP", RFC 2560,
                  June 1999.

   [RFC2585]      Housley, R. and P. Hoffman, "Internet X.509 Public Key
                  Infrastructure Operational Protocols: FTP and HTTP",
                  RFC 2585, May 1999.

   [RFC2616]      Fielding, R., Gettys, J., Mogul, J., Frystyk, H.,
                  Masinter, L., Leach, P., and T. Berners-Lee,
                  "Hypertext Transfer Protocol -- HTTP/1.1", RFC 2616,
                  June 1999.

   [RFC3986]      Berners-Lee, T., Fielding, R., and L. Masinter,
                  "Uniform Resource Identifier (URI): Generic Syntax",
                  STD 66, RFC 3986, January 2005.



Eastlake                     Standards Track                   [Page 22]
   __________________________________________________________________


RFC 6066                TLS Extension Definitions           January 2011


   [RFC5246]      Dierks, T. and E. Rescorla, "The Transport Layer
                  Security (TLS) Protocol Version 1.2", RFC 5246, August
                  2008.

   [RFC5280]      Cooper, D., Santesson, S., Farrell, S., Boeyen, S.,
                  Housley, R., and W. Polk, "Internet X.509 Public Key
                  Infrastructure Certificate and Certificate Revocation
                  List (CRL) Profile", RFC 5280, May 2008.

   [RFC5890]      Klensin, J., "Internationalized Domain Names for
                  Applications (IDNA): Definitions and Document
                  Framework", RFC 5890, August 2010.

13.  Informative References

   [RFC2712]      Medvinsky, A. and M. Hur, "Addition of Kerberos Cipher
                  Suites to Transport Layer Security (TLS)", RFC 2712,
                  October 1999.

   [X509-4th]     ITU-T Recommendation X.509 (2000) | ISO/IEC
                  9594-8:2001, "Information Systems - Open Systems
                  Interconnection - The Directory: Public key and
                  attribute certificate frameworks".

   [X509-4th-TC1] ITU-T Recommendation X.509(2000) Corrigendum 1(2001) |
                  ISO/IEC 9594-8:2001/Cor.1:2002, Technical Corrigendum
                  1 to ISO/IEC 9594:8:2001.
























Eastlake                     Standards Track                   [Page 23]
   __________________________________________________________________


RFC 6066                TLS Extension Definitions           January 2011


Appendix A.  Changes from RFC 4366

   The significant changes between RFC 4366 and this document are
   described below.

   RFC 4366 described both general extension mechanisms (for the TLS
   handshake and client and server hellos) as well as specific
   extensions.  RFC 4366 was associated with RFC 4346, TLS 1.1.  The
   client and server hello extension mechanisms have been moved into RFC
   5246, TLS 1.2, so this document, which is associated with RFC 5246,
   includes only the handshake extension mechanisms and the specific
   extensions from RFC 4366.  RFC 5246 also specifies the unknown
   extension error and new extension specification considerations, so
   that material has been removed from this document.

   The Server Name extension now specifies only ASCII representation,
   eliminating UTF-8.  It is provided that the ServerNameList can
   contain more than only one name of any particular name_type.  If a
   server name is provided but not recognized, the server should either
   continue the handshake without an error or send a fatal error.
   Sending a warning-level message is not recommended because client
   behavior will be unpredictable.  Provision was added for the user
   using the server_name extension in deciding whether or not to resume
   a session.  Furthermore, this extension should be the same in a
   session resumption request as it was in the full handshake that
   established the session.  Such a resumption request must not be
   accepted if the server_name extension is different, but instead a
   full handshake must be done to possibly establish a new session.

   The Client Certificate URLs extension has been changed to make the
   presence of a hash mandatory.

   For the case of DTLS, the requirement to report an overflow of the
   negotiated maximum fragment length is made conditional on passing
   authentication.

   TLS servers are now prohibited from following HTTP redirects when
   retrieving certificates.

   The material was also re-organized in minor ways.  For example,
   information as to which errors are fatal is moved from the "Error
   Alerts" section to the individual extension specifications.









Eastlake                     Standards Track                   [Page 24]
   __________________________________________________________________


RFC 6066                TLS Extension Definitions           January 2011


Appendix B.  Acknowledgements

   This document is based on material from RFC 4366 for which the
   authors were S. Blake-Wilson, M. Nystrom, D. Hopwood, J. Mikkelsen,
   and T. Wright.  Other contributors include Joseph Salowey, Alexey
   Melnikov, Peter Saint-Andre, and Adrian Farrel.

Author's Address

   Donald Eastlake 3rd
   Huawei
   155 Beaver Street
   Milford, MA 01757 USA

   Phone: +1-508-333-2270
   EMail: d3e3e3@gmail.com



































Eastlake                     Standards Track                   [Page 25]


   Html markup produced by rfcmarkup 1.129c, available from
   https://tools.ietf.org/tools/rfcmarkup/
   [Docs] [txt|pdf] [draft-ietf-tls-...] [Tracker] [Diff1] [Diff2] [IPR]
   [Errata]
   Obsoleted by: 8446 PROPOSED STANDARD
   Errata Exist
Internet Engineering Task Force (IETF)                      Y. Pettersen
Request for Comments: 6961                                     June 2013
Category: Standards Track
ISSN: 2070-1721


                   The Transport Layer Security (TLS)
             Multiple Certificate Status Request Extension

Abstract

   This document defines the Transport Layer Security (TLS) Certificate
   Status Version 2 Extension to allow clients to specify and support
   several certificate status methods.  (The use of the Certificate
   Status extension is commonly referred to as "OCSP stapling".)  Also
   defined is a new method based on the Online Certificate Status
   Protocol (OCSP) that servers can use to provide status information
   about not only the server's own certificate but also the status of
   intermediate certificates in the chain.

Status of This Memo

   This is an Internet Standards Track document.

   This document is a product of the Internet Engineering Task Force
   (IETF).  It represents the consensus of the IETF community.  It has
   received public review and has been approved for publication by the
   Internet Engineering Steering Group (IESG).  Further information on
   Internet Standards is available in Section 2 of RFC 5741.

   Information about the current status of this document, any errata,
   and how to provide feedback on it may be obtained at
   http://www.rfc-editor.org/info/rfc6961.


















Pettersen                    Standards Track                    [Page 1]
   __________________________________________________________________


RFC 6961          Multiple Certificate Status Extension        June 2013


Copyright Notice

   Copyright (c) 2013 IETF Trust and the persons identified as the
   document authors.  All rights reserved.

   This document is subject to BCP 78 and the IETF Trust's Legal
   Provisions Relating to IETF Documents
   (http://trustee.ietf.org/license-info) in effect on the date of
   publication of this document.  Please review these documents
   carefully, as they describe your rights and restrictions with respect
   to this document.  Code Components extracted from this document must
   include Simplified BSD License text as described in Section 4.e of
   the Trust Legal Provisions and are provided without warranty as
   described in the Simplified BSD License.

   This document may contain material from IETF Documents or IETF
   Contributions published or made publicly available before November
   10, 2008.  The person(s) controlling the copyright in some of this
   material may not have granted the IETF Trust the right to allow
   modifications of such material outside the IETF Standards Process.
   Without obtaining an adequate license from the person(s) controlling
   the copyright in such materials, this document may not be modified
   outside the IETF Standards Process, and derivative works of it may
   not be created outside the IETF Standards Process, except to format
   it for publication as an RFC or to translate it into languages other
   than English.

1.  Introduction

   The Transport Layer Security (TLS) Extension [RFC6066] framework
   defines, among other extensions, the Certificate Status extension
   (also referred to as "OCSP stapling") that clients can use to request
   the server's copy of the current status of its certificate.  The
   benefits of this extension include a reduced number of roundtrips and
   network delays for the client to verify the status of the server's
   certificate and a reduced load on the certificate issuer's status
   response servers, thus solving a problem that can become significant
   when the issued certificate is presented by a frequently visited
   server.

   There are two problems with the existing Certificate Status
   extension.  First, it does not provide functionality to request the
   status information about intermediate Certification Authority (CA)
   certificates, which means the client has to request status
   information through other methods, such as Certificate Revocation
   Lists (CRLs), introducing further delays.  Second, the current format
   of the extension and requirements in the TLS protocol prevent a
   client from offering the server multiple status methods.



Pettersen                    Standards Track                    [Page 2]
   __________________________________________________________________


RFC 6961          Multiple Certificate Status Extension        June 2013


   Many CAs are now issuing intermediate CA certificates that not only
   specify the publication point for their CRLs in a CRL Distribution
   Point [RFC5280] but also specify a URL for their OCSP [RFC6960]
   server in Authority Information Access [RFC5280].  Given that
   client-cached CRLs are frequently out of date, clients would benefit
   from using OCSP to access up-to-date status information about
   intermediate CA certificates.  The benefit to the issuing CA is less
   clear, as providing the bandwidth for the OCSP responder can be
   costly, especially for CAs with many high-traffic subscriber sites,
   and this cost is a concern for many CAs.  There are cases where OCSP
   requests for a single high-traffic site caused significant network
   problems for the issuing CA.

   Clients will benefit from the TLS server providing certificate status
   information regardless of type, not just for the server certificate
   but also for the intermediate CA certificates.  Combining the status
   checks into one extension will reduce the roundtrips needed to
   complete the handshake by the client to just those needed for
   negotiating the TLS connection.  Also, for the Certification
   Authorities, the load on their servers will depend on the number of
   certificates they have issued, not on the number of visitors to those
   sites.  Additionally, using this extension significantly reduces
   privacy concerns around the clients informing the certificate issuer
   about which sites they are visiting.

   For such a new system to be introduced seamlessly, clients need to be
   able to indicate support for the existing OCSP Certificate Status
   method and a new multiple-OCSP mode.

   Unfortunately, the definition of the Certificate Status extension
   only allows a single Certificate Status extension to be defined in a
   single extension record in the handshake, and the TLS protocol
   [RFC5246] only allows a single record in the extension list for any
   given extension.  This means that it is not possible for clients to
   indicate support for new methods while still supporting older
   methods, which would cause problems for interoperability between
   newer clients and older servers.  This will not just be an issue for
   the multiple status request mode proposed above but also for any
   other future status methods that might be introduced.  This will be
   true not just for the current PKIX infrastructure [RFC5280] but also
   for alternative PKI structures.

   The solution to this problem is to define a new extension,
   "status_request_v2", with an extended format that allows the client
   to indicate support for multiple status request methods.  This is
   implemented using a list of CertificateStatusRequestItemV2 records in
   the extension record.  As the server will select the single status




Pettersen                    Standards Track                    [Page 3]
   __________________________________________________________________


RFC 6961          Multiple Certificate Status Extension        June 2013


   method based on the selected cipher suite and the certificate
   presented, no significant changes are needed in the server's
   extension format.

1.1.  Requirements Language

   The key words "MUST", "MUST NOT", "REQUIRED", "SHALL", "SHALL NOT",
   "SHOULD", "SHOULD NOT", "RECOMMENDED", "MAY", and "OPTIONAL" in this
   document are to be interpreted as described in RFC 2119 [RFC2119].

1.2.  Presentation Language

   This document defines protocol structures using the same conventions
   and presentation language as defined in Section 4 of [RFC5246].

2.  Multiple Certificate Status Extension

2.1.  New Extension

   The extension defined by this document is indicated by
   "status_request_v2" in the ExtensionType enum (originally defined by
   [RFC6066]), which uses the following value:

     enum {
       status_request_v2(17), (65535)
     } ExtensionType;

2.2.  Multiple Certificate Status Request Record

   Clients that support a certificate status protocol like OCSP may send
   the "status_request_v2" extension to the server in order to use the
   TLS handshake to transfer such data instead of downloading it through
   separate connections.  When using this extension, the
   "extension_data" field (defined in Section 7.4.1.4 of [RFC5246]) of
   the extension SHALL contain a CertificateStatusRequestListV2 where:

     struct {
       CertificateStatusType status_type;
       uint16 request_length; /* Length of request field in bytes */
       select (status_type) {
         case ocsp: OCSPStatusRequest;
         case ocsp_multi: OCSPStatusRequest;
       } request;
     } CertificateStatusRequestItemV2;

     enum { ocsp(1), ocsp_multi(2), (255) } CertificateStatusType;





Pettersen                    Standards Track                    [Page 4]
   __________________________________________________________________


RFC 6961          Multiple Certificate Status Extension        June 2013


     struct {
       ResponderID responder_id_list<0..2^16-1>;
       Extensions request_extensions;
     } OCSPStatusRequest;

     opaque ResponderID<1..2^16-1>;
     opaque Extensions<0..2^16-1>;

     struct {
       CertificateStatusRequestItemV2
                        certificate_status_req_list<1..2^16-1>;
     } CertificateStatusRequestListV2;

   In the OCSPStatusRequest (originally defined by [RFC6066]), the
   "ResponderID" provides a list of OCSP responders that the client
   trusts.  A zero-length "responder_id_list" sequence has the special
   meaning that the responders are implicitly known to the server, e.g.,
   by prior arrangement, or are identified by the certificates used by
   the server.  "Extensions" is a DER encoding [X.690] of the OCSP
   request extensions, and if the server supports the forwarding of OCSP
   request extensions, this value MUST be forwarded without
   modification.

   Both "ResponderID" and "Extensions" are DER-encoded ASN.1 types as
   defined in [RFC6960].  "Extensions" is imported from [RFC5280].  A
   zero-length "request_extensions" value means that there are no
   extensions (as opposed to a DER-encoded zero-length ASN.1 SEQUENCE,
   which is not valid for the "Extensions" type).

   Servers that support a client's selection of responders using the
   ResponderID field could implement this selection by matching the
   responder ID values from the client's list with the ResponderIDs of
   known OCSP responders, either by using a binary compare of the values
   or a hash calculation and compare method.

   In the case of the "id-pkix-ocsp-nonce" OCSP extension, [RFC2560] is
   unclear about its encoding; for clarification, the nonce MUST be a
   DER-encoded OCTET STRING, which is encapsulated as another OCTET
   STRING (note that implementations based on an existing OCSP client
   will need to be checked for conformance to this requirement).  This
   has been clarified in [RFC6960].

   The items in the list of CertificateStatusRequestItemV2 entries are
   ordered according to the client's preference (favorite choice first).

   A server that receives a client hello containing the
   "status_request_v2" extension MAY return a suitable certificate
   status response message to the client along with the server's



Pettersen                    Standards Track                    [Page 5]
   __________________________________________________________________


RFC 6961          Multiple Certificate Status Extension        June 2013


   certificate message.  If OCSP is requested, it SHOULD use the
   information contained in the extension when selecting an OCSP
   responder and SHOULD include request_extensions in the OCSP request.

   The server returns a certificate status response along with its
   certificate by sending a "CertificateStatus" message (originally
   defined by [RFC6066]) immediately after the "Certificate" message
   (Section 7.4.2 of [RFC5246]) (and before any "ServerKeyExchange" or
   "CertificateRequest" messages).  If a server returns a
   "CertificateStatus" message in response to a "status_request_v2"
   request, then the server MUST have included an extension of type
   "status_request_v2" with empty "extension_data" in the extended
   server hello.

   The "CertificateStatus" message is conveyed using the handshake
   message type "certificate_status" (defined in [RFC6066]) as follows
   (updated from the definition in [RFC6066]):

     struct {
       CertificateStatusType status_type;
       select (status_type) {
         case ocsp: OCSPResponse;
         case ocsp_multi: OCSPResponseList;
       } response;
     } CertificateStatus;

     opaque OCSPResponse<0..2^24-1>;

     struct {
       OCSPResponse ocsp_response_list<1..2^24-1>;
     } OCSPResponseList;

   An "OCSPResponse" element (originally defined by [RFC6066]) contains
   a complete, DER-encoded OCSP response (using the ASN.1 [X.680] type
   OCSPResponse defined in [RFC6960]).  Only one OCSP response, with a
   length of at least one byte, may be sent for status_type "ocsp".

   An "ocsp_response_list" contains a list of "OCSPResponse" elements,
   as specified above, each containing the OCSP response for the
   matching corresponding certificate in the server's Certificate TLS
   handshake message.  That is, the first entry is the OCSP response for
   the first certificate in the Certificate list, the second entry is
   the response for the second certificate, and so on.  The list MAY
   contain fewer OCSP responses than there were certificates in the
   Certificate handshake message, but there MUST NOT be more responses
   than there were certificates in the list.  Individual elements of the
   list MAY have a length of 0 (zero) bytes if the server does not have
   the OCSP response for that particular certificate stored, in which



Pettersen                    Standards Track                    [Page 6]
   __________________________________________________________________


RFC 6961          Multiple Certificate Status Extension        June 2013


   case the client MUST act as if a response was not received for that
   particular certificate.  If the client receives a
   "ocsp_response_list" that does not contain a response for one or more
   of the certificates in the completed certificate chain, the client
   SHOULD attempt to validate the certificate using an alternative
   retrieval method, such as downloading the relevant CRL; OCSP SHOULD
   in this situation only be used for the end-entity certificate, not
   intermediate CA certificates, for reasons stated above.

   Note that a server MAY also choose not to send a "CertificateStatus"
   message, even if it has received a "status_request_v2" extension in
   the client hello message and has sent a "status_request_v2" extension
   in the server hello message.  Additionally, note that a server MUST
   NOT send the "CertificateStatus" message unless it received either a
   "status_request" or "status_request_v2" extension in the client hello
   message and sent a corresponding "status_request" or
   "status_request_v2" extension in the server hello message.

   Clients requesting an OCSP response and receiving one or more OCSP
   responses in a "CertificateStatus" message MUST check the OCSP
   response(s) and abort the handshake if the response is a "revoked"
   status or other unacceptable responses (as determined by client
   policy) with a bad_certificate_status_response(113) alert.  This
   alert is always fatal.

   If the OCSP response received from the server does not result in a
   definite "good" or "revoked" status, it is inconclusive.  A TLS
   client in such a case MAY check the validity of the server
   certificate through other means, e.g., by directly querying the
   certificate issuer.  If such processing still results in an
   inconclusive response, then the application using the TLS connection
   will have to decide whether to close the connection or not.  Note
   that this problem cannot be decided by the generic TLS client code
   without information from the application.  If the application doesn't
   provide any such information, then the client MUST abort the
   connection, since the server certificate has not been sufficiently
   validated.

   An example of where the application might wish to continue is with
   EAP-TLS (Extensible Authentication Protocol - TLS), where the
   application can use another mechanism to check the status of a
   certificate once it obtains network access.  In this case, the
   application could have the client continue with the handshake, but it
   MUST NOT disclose a username and password until it has fully
   validated the server certificate.






Pettersen                    Standards Track                    [Page 7]
   __________________________________________________________________


RFC 6961          Multiple Certificate Status Extension        June 2013


3.  IANA Considerations

   Section 2.1 defines the new TLS extension status_request_v2 (17)
   enum, which has been added to the "ExtensionType Values" list in the
   IANA "Transport Layer Security (TLS) Extensions" registry.

   Section 2.2 describes a TLS CertificateStatusType registry that is
   now maintained by IANA.  The "TLS Certificate Status Types" registry
   has been created under the "Transport Layer Security (TLS)
   Extensions" registry.  CertificateStatusType values are to be
   assigned via IETF Review as defined in [RFC5226].  The initial
   registry corresponds to the definition of "CertificateStatusType" in
   Section 2.2.

   Value   Description   Reference
   -----------------------------------------
   0       Reserved      [RFC6961]
   1       ocsp          [RFC6066] [RFC6961]
   2       ocsp_multi    [RFC6961]
   3-255   Unassigned

4.  Security Considerations

   General security considerations for TLS extensions are covered in
   [RFC5246].  Security considerations for the particular extension
   specified in this document are given below.  In general, implementers
   should continue to monitor the state of the art and address any
   weaknesses identified.

4.1.  Security Considerations for status_request_v2

   If a client requests an OCSP response, it must take into account that
   an attacker's server using a compromised key could (and probably
   would) pretend not to support the extension.  In this case, a client
   that requires OCSP validation of certificates SHOULD either contact
   the OCSP server directly or abort the handshake.

   Use of the OCSP nonce request extension (id-pkix-ocsp-nonce) may
   improve security against attacks that attempt to replay OCSP
   responses; see Section 4.4.1 of [RFC6960] for further details.

   This extension allows the client to send arbitrary data to the
   server.  The server implementers need to handle such data carefully
   to avoid introducing security vulnerabilities.

   The security considerations of [RFC6960] apply to OCSP requests and
   responses.




Pettersen                    Standards Track                    [Page 8]
   __________________________________________________________________


RFC 6961          Multiple Certificate Status Extension        June 2013


5.  Acknowledgements

   This document is based on [RFC6066], authored by Donald Eastlake 3rd.

6.  References

6.1.  Normative References

   [RFC2119]  Bradner, S., "Key words for use in RFCs to Indicate
              Requirement Levels", BCP 14, RFC 2119, March 1997.

   [RFC5226]  Narten, T. and H. Alvestrand, "Guidelines for Writing an
              IANA Considerations Section in RFCs", BCP 26, RFC 5226,
              May 2008.

   [RFC5246]  Dierks, T. and E. Rescorla, "The Transport Layer Security
              (TLS) Protocol Version 1.2", RFC 5246, August 2008.

   [RFC5280]  Cooper, D., Santesson, S., Farrell, S., Boeyen, S.,
              Housley, R., and W. Polk, "Internet X.509 Public Key
              Infrastructure Certificate and Certificate Revocation List
              (CRL) Profile", RFC 5280, May 2008.

   [RFC6066]  Eastlake, D., "Transport Layer Security (TLS) Extensions:
              Extension Definitions", RFC 6066, January 2011.

   [RFC6960]  Santesson, S., Myers, M., Ankney, R., Malpani, A.,
              Galperin, S., and C. Adams, "X.509 Internet Public Key
              Infrastructure Online Certificate Status Protocol - OCSP",
              RFC 6960, June 2013.

   [X.680]    ITU-T Recommendation X.680 (2008) | ISO/IEC 8824-1:2008,
              "Abstract Syntax Notation One (ASN.1): Specification of
              basic notation", November 2008.

   [X.690]    ITU-T Recommendation X.690 (2008) | ISO/IEC 8825-1:2008,
              "ASN.1 encoding rules: Specification of Basic Encoding
              Rules (BER), Canonical Encoding Rules (CER) and
              Distinguished Encoding Rules (DER)", November 2008.

6.2.  Informative References

   [RFC2560]  Myers, M., Ankney, R., Malpani, A., Galperin, S., and C.
              Adams, "X.509 Internet Public Key Infrastructure Online
              Certificate Status Protocol - OCSP", RFC 2560, June 1999.






Pettersen                    Standards Track                    [Page 9]
   __________________________________________________________________


RFC 6961          Multiple Certificate Status Extension        June 2013


Author's Address

   Yngve N. Pettersen

   EMail: yngve@spec-work.net














































Pettersen                    Standards Track                   [Page 10]


   Html markup produced by rfcmarkup 1.129c, available from
   https://tools.ietf.org/tools/rfcmarkup/
   [Docs] [txt|pdf] [draft-ietf-tls-...] [Tracker] [Diff1] [Diff2]
   [Errata]
   PROPOSED STANDARD
   Errata Exist
Internet Engineering Task Force (IETF)                   P. Wouters, Ed.
Request for Comments: 7250                                       Red Hat
Category: Standards Track                             H. Tschofenig, Ed.
ISSN: 2070-1721                                                 ARM Ltd.
                                                              J. Gilmore
                                          Electronic Frontier Foundation
                                                               S. Weiler
                                                                 Parsons
                                                              T. Kivinen
                                                           INSIDE Secure
                                                               June 2014


        Using Raw Public Keys in Transport Layer Security (TLS)
              and Datagram Transport Layer Security (DTLS)

Abstract

   This document specifies a new certificate type and two TLS extensions
   for exchanging raw public keys in Transport Layer Security (TLS) and
   Datagram Transport Layer Security (DTLS).  The new certificate type
   allows raw public keys to be used for authentication.

Status of This Memo

   This is an Internet Standards Track document.

   This document is a product of the Internet Engineering Task Force
   (IETF).  It represents the consensus of the IETF community.  It has
   received public review and has been approved for publication by the
   Internet Engineering Steering Group (IESG).  Further information on
   Internet Standards is available in Section 2 of RFC 5741.

   Information about the current status of this document, any errata,
   and how to provide feedback on it may be obtained at
   http://www.rfc-editor.org/info/rfc7250.















Wouters, et al.              Standards Track                    [Page 1]
   __________________________________________________________________


RFC 7250            Using Raw Public Keys in TLS/DTLS          June 2014


Copyright Notice

   Copyright (c) 2014 IETF Trust and the persons identified as the
   document authors.  All rights reserved.

   This document is subject to BCP 78 and the IETF Trust's Legal
   Provisions Relating to IETF Documents
   (http://trustee.ietf.org/license-info) in effect on the date of
   publication of this document.  Please review these documents
   carefully, as they describe your rights and restrictions with respect
   to this document.  Code Components extracted from this document must
   include Simplified BSD License text as described in Section 4.e of
   the Trust Legal Provisions and are provided without warranty as
   described in the Simplified BSD License.

Table of Contents

   1.  Introduction  . . . . . . . . . . . . . . . . . . . . . . . .   3
   2.  Terminology . . . . . . . . . . . . . . . . . . . . . . . . .   4
   3.  Structure of the Raw Public Key Extension . . . . . . . . . .   4
   4.  TLS Client and Server Handshake Behavior  . . . . . . . . . .   7
     4.1.  Client Hello  . . . . . . . . . . . . . . . . . . . . . .   7
     4.2.  Server Hello  . . . . . . . . . . . . . . . . . . . . . .   8
     4.3.  Client Authentication . . . . . . . . . . . . . . . . . .   9
     4.4.  Server Authentication . . . . . . . . . . . . . . . . . .   9
   5.  Examples  . . . . . . . . . . . . . . . . . . . . . . . . . .  10
     5.1.  TLS Server Uses a Raw Public Key  . . . . . . . . . . . .  10
     5.2.  TLS Client and Server Use Raw Public Keys . . . . . . . .  11
     5.3.  Combined Usage of Raw Public Keys and X.509 Certificates   12
   6.  Security Considerations . . . . . . . . . . . . . . . . . . .  13
   7.  IANA Considerations . . . . . . . . . . . . . . . . . . . . .  14
   8.  Acknowledgements  . . . . . . . . . . . . . . . . . . . . . .  14
   9.  References  . . . . . . . . . . . . . . . . . . . . . . . . .  15
     9.1.  Normative References  . . . . . . . . . . . . . . . . . .  15
     9.2.  Informative References  . . . . . . . . . . . . . . . . .  15
   Appendix A.  Example Encoding . . . . . . . . . . . . . . . . . .  17















Wouters, et al.              Standards Track                    [Page 2]
   __________________________________________________________________


RFC 7250            Using Raw Public Keys in TLS/DTLS          June 2014


1.  Introduction

   Traditionally, TLS client and server public keys are obtained in PKIX
   containers in-band as part of the TLS handshake procedure and are
   validated using trust anchors based on a [PKIX] certification
   authority (CA).  This method can add a complicated trust relationship
   that is difficult to validate.  Examples of such complexity can be
   seen in [Defeating-SSL].  TLS is, however, also commonly used with
   self-signed certificates in smaller deployments where the self-signed
   certificates are distributed to all involved protocol endpoints out-
   of-band.  This practice does, however, still require the overhead of
   the certificate generation even though none of the information found
   in the certificate is actually used.

   Alternative methods are available that allow a TLS client/server to
   obtain the TLS server/client public key:

   o  The TLS client can obtain the TLS server public key from a DNSSEC-
      secured resource record using DNS-Based Authentication of Named
      Entities (DANE) [RFC6698].

   o  The TLS client or server public key is obtained from a [PKIX]
      certificate chain from a Lightweight Directory Access Protocol
      [LDAP] server or web page.

   o  The TLS client and server public key is provisioned into the
      operating system firmware image and updated via software updates.
      For example:

      Some smart objects use the UDP-based Constrained Application
      Protocol [CoAP] to interact with a Web server to upload sensor
      data at regular intervals, such as temperature readings.  CoAP can
      utilize DTLS for securing the client-to-server communication.  As
      part of the manufacturing process, the embedded device may be
      configured with the address and the public key of a dedicated CoAP
      server, as well as a public/private key pair for the client
      itself.

   This document introduces the use of raw public keys in TLS/DTLS.
   With raw public keys, only a subset of the information found in
   typical certificates is utilized: namely, the SubjectPublicKeyInfo
   structure of a PKIX certificate that carries the parameters necessary
   to describe the public key.  Other parameters found in PKIX
   certificates are omitted.  By omitting various certificate-related
   structures, the resulting raw public key is kept fairly small in
   comparison to the original certificate, and the code to process the
   keys can be simpler.  Only a minimalistic ASN.1 parser is needed;
   code for certificate path validation and other PKIX-related



Wouters, et al.              Standards Track                    [Page 3]
   __________________________________________________________________


RFC 7250            Using Raw Public Keys in TLS/DTLS          June 2014


   processing is not required.  Note, however, the SubjectPublicKeyInfo
   structure is still in an ASN.1 format.  To further reduce the size of
   the exchanged information, this specification can be combined with
   the TLS Cached Info extension [CACHED-INFO], which enables TLS peers
   to exchange just fingerprints of their public keys.

   The mechanism defined herein only provides authentication when an
   out-of-band mechanism is also used to bind the public key to the
   entity presenting the key.

   Section 3 defines the structure of the two new TLS extensions,
   client_certificate_type and server_certificate_type, which can be
   used as part of an extended TLS handshake when raw public keys are to
   be used.  Section 4 defines the behavior of the TLS client and the
   TLS server.  Example exchanges are described in Section 5.  Section 6
   describes security considerations with this approach.  Finally, in
   Section 7 this document registers a new value to the IANA "TLS
   Certificate Types" subregistry for the support of raw public keys.

2.  Terminology

   The key words "MUST", "MUST NOT", "REQUIRED", "SHALL", "SHALL NOT",
   "SHOULD", "SHOULD NOT", "RECOMMENDED", "MAY", and "OPTIONAL" in this
   document are to be interpreted as described in RFC 2119 [RFC2119].

   We use the terms "TLS server" and "server" as well as "TLS client"
   and "client" interchangeably.

3.  Structure of the Raw Public Key Extension

   This section defines the two TLS extensions client_certificate_type
   and server_certificate_type, which can be used as part of an extended
   TLS handshake when raw public keys are used.  Section 4 defines the
   behavior of the TLS client and the TLS server using these extensions.

   This specification uses raw public keys whereby the already available
   encoding used in a PKIX certificate in the form of a
   SubjectPublicKeyInfo structure is reused.  To carry the raw public
   key within the TLS handshake, the Certificate payload is used as a
   container, as shown in Figure 1.  The shown Certificate structure is
   an adaptation of its original form [RFC5246].










Wouters, et al.              Standards Track                    [Page 4]
   __________________________________________________________________


RFC 7250            Using Raw Public Keys in TLS/DTLS          June 2014


   opaque ASN.1Cert<1..2^24-1>;

   struct {
       select(certificate_type){

            // certificate type defined in this document.
            case RawPublicKey:
              opaque ASN.1_subjectPublicKeyInfo<1..2^24-1>;

           // X.509 certificate defined in RFC 5246
           case X.509:
             ASN.1Cert certificate_list<0..2^24-1>;

           // Additional certificate type based on
           // "TLS Certificate Types" subregistry
       };
   } Certificate;

    Figure 1: Certificate Payload as a Container for the Raw Public Key

   The SubjectPublicKeyInfo structure is defined in Section 4.1 of RFC
   5280 [PKIX] and not only contains the raw keys, such as the public
   exponent and the modulus of an RSA public key, but also an algorithm
   identifier.  The algorithm identifier can also include parameters.
   The SubjectPublicKeyInfo value in the Certificate payload MUST
   contain the DER encoding [X.690] of the SubjectPublicKeyInfo.  The
   structure, as shown in Figure 2, therefore also contains length
   information.  An example is provided in Appendix A.

      SubjectPublicKeyInfo  ::=  SEQUENCE  {
           algorithm               AlgorithmIdentifier,
           subjectPublicKey        BIT STRING  }

      AlgorithmIdentifier   ::=  SEQUENCE  {
           algorithm               OBJECT IDENTIFIER,
           parameters              ANY DEFINED BY algorithm OPTIONAL  }

              Figure 2: SubjectPublicKeyInfo ASN.1 Structure

   The algorithm identifiers are Object Identifiers (OIDs).  RFC 3279
   [RFC3279] and RFC 5480 [RFC5480], for example, define the OIDs shown
   in Figure 3.  Note that this list is not exhaustive, and more OIDs
   may be defined in future RFCs.








Wouters, et al.              Standards Track                    [Page 5]
   __________________________________________________________________


RFC 7250            Using Raw Public Keys in TLS/DTLS          June 2014


   Key Type            | Document                   | OID
   --------------------+----------------------------+-------------------
   RSA                 | Section 2.3.1 of RFC 3279  | 1.2.840.113549.1.1
   ....................|............................|...................
   Digital Signature   |                            |
   Algorithm (DSA)     | Section 2.3.2 of RFC 3279  | 1.2.840.10040.4.1
   ....................|............................|...................
   Elliptic Curve      |                            |
   Digital Signature   |                            |
   Algorithm (ECDSA)   | Section 2 of RFC 5480      | 1.2.840.10045.2.1
   --------------------+----------------------------+-------------------

              Figure 3: Example Algorithm Object Identifiers

   The extension format for extended client and server hellos, which
   uses the "extension_data" field, is used to carry the
   ClientCertTypeExtension and the ServerCertTypeExtension structures.
   These two structures are shown in Figure 4.  The CertificateType
   structure is an enum with values taken from the "TLS Certificate
   Types" subregistry of the "Transport Layer Security (TLS) Extensions"
   registry [TLS-Ext-Registry].

   struct {
           select(ClientOrServerExtension) {
               case client:
                 CertificateType client_certificate_types<1..2^8-1>;
               case server:
                 CertificateType client_certificate_type;
           }
   } ClientCertTypeExtension;

   struct {
           select(ClientOrServerExtension) {
               case client:
                 CertificateType server_certificate_types<1..2^8-1>;
               case server:
                 CertificateType server_certificate_type;
           }
   } ServerCertTypeExtension;

                   Figure 4: CertTypeExtension Structure










Wouters, et al.              Standards Track                    [Page 6]
   __________________________________________________________________


RFC 7250            Using Raw Public Keys in TLS/DTLS          June 2014


4.  TLS Client and Server Handshake Behavior

   This specification extends the ClientHello and the ServerHello
   messages, according to the extension procedures defined in [RFC5246].
   It does not extend or modify any other TLS message.

   Note: No new cipher suites are required to use raw public keys.  All
   existing cipher suites that support a key exchange method compatible
   with the defined extension can be used.

   The high-level message exchange in Figure 5 shows the
   client_certificate_type and server_certificate_type extensions added
   to the client and server hello messages.

    client_hello,
    client_certificate_type,
    server_certificate_type   ->

                              <-  server_hello,
                                  client_certificate_type,
                                  server_certificate_type,
                                  certificate,
                                  server_key_exchange,
                                  certificate_request,
                                  server_hello_done
    certificate,
    client_key_exchange,
    certificate_verify,
    change_cipher_spec,
    finished                  ->

                              <- change_cipher_spec,
                                 finished

   Application Data        <------->     Application Data

                Figure 5: Basic Raw Public Key TLS Exchange

4.1.  Client Hello

   In order to indicate the support of raw public keys, clients include
   the client_certificate_type and/or the server_certificate_type
   extensions in an extended client hello message.  The hello extension
   mechanism is described in Section 7.4.1.4 of TLS 1.2 [RFC5246].

   The client_certificate_type extension in the client hello indicates
   the certificate types the client is able to provide to the server,
   when requested using a certificate_request message.



Wouters, et al.              Standards Track                    [Page 7]
   __________________________________________________________________


RFC 7250            Using Raw Public Keys in TLS/DTLS          June 2014


   The server_certificate_type extension in the client hello indicates
   the types of certificates the client is able to process when provided
   by the server in a subsequent certificate payload.

   The client_certificate_type and server_certificate_type extensions
   sent in the client hello each carry a list of supported certificate
   types, sorted by client preference.  When the client supports only
   one certificate type, it is a list containing a single element.

   The TLS client MUST omit certificate types from the
   client_certificate_type extension in the client hello if it does not
   possess the corresponding raw public key or certificate that it can
   provide to the server when requested using a certificate_request
   message, or if it is not configured to use one with the given TLS
   server.  If the client has no remaining certificate types to send in
   the client hello, other than the default X.509 type, it MUST omit the
   client_certificate_type extension in the client hello.

   The TLS client MUST omit certificate types from the
   server_certificate_type extension in the client hello if it is unable
   to process the corresponding raw public key or other certificate
   type.  If the client has no remaining certificate types to send in
   the client hello, other than the default X.509 certificate type, it
   MUST omit the entire server_certificate_type extension from the
   client hello.

4.2.  Server Hello

   If the server receives a client hello that contains the
   client_certificate_type extension and/or the server_certificate_type
   extension, then three outcomes are possible:

   1.  The server does not support the extension defined in this
       document.  In this case, the server returns the server hello
       without the extensions defined in this document.

   2.  The server supports the extension defined in this document, but
       it does not have any certificate type in common with the client.
       Then, the server terminates the session with a fatal alert of
       type "unsupported_certificate".

   3.  The server supports the extensions defined in this document and
       has at least one certificate type in common with the client.  In
       this case, the processing rules described below are followed.

   The client_certificate_type extension in the client hello indicates
   the certificate types the client is able to provide to the server,
   when requested using a certificate_request message.  If the TLS



Wouters, et al.              Standards Track                    [Page 8]
   __________________________________________________________________


RFC 7250            Using Raw Public Keys in TLS/DTLS          June 2014


   server wants to request a certificate from the client (via the
   certificate_request message), it MUST include the
   client_certificate_type extension in the server hello.  This
   client_certificate_type extension in the server hello then indicates
   the type of certificates the client is requested to provide in a
   subsequent certificate payload.  The value conveyed in the
   client_certificate_type extension MUST be selected from one of the
   values provided in the client_certificate_type extension sent in the
   client hello.  The server MUST also include a certificate_request
   payload in the server hello message.

   If the server does not send a certificate_request payload (for
   example, because client authentication happens at the application
   layer or no client authentication is required) or none of the
   certificates supported by the client (as indicated in the
   client_certificate_type extension in the client hello) match the
   server-supported certificate types, then the client_certificate_type
   payload in the server hello MUST be omitted.

   The server_certificate_type extension in the client hello indicates
   the types of certificates the client is able to process when provided
   by the server in a subsequent certificate payload.  If the client
   hello indicates support of raw public keys in the
   server_certificate_type extension and the server chooses to use raw
   public keys, then the TLS server MUST place the SubjectPublicKeyInfo
   structure into the Certificate payload.  With the
   server_certificate_type extension in the server hello, the TLS server
   indicates the certificate type carried in the Certificate payload.
   This additional indication enables avoiding parsing ambiguities since
   the Certificate payload may contain either the X.509 certificate or a
   SubjectPublicKeyInfo structure.  Note that only a single value is
   permitted in the server_certificate_type extension when carried in
   the server hello.

4.3.  Client Authentication

   When the TLS server has specified RawPublicKey as the
   client_certificate_type, authentication of the TLS client to the TLS
   server is supported only through authentication of the received
   client SubjectPublicKeyInfo via an out-of-band method.

4.4.  Server Authentication

   When the TLS server has specified RawPublicKey as the
   server_certificate_type, authentication of the TLS server to the TLS
   client is supported only through authentication of the received
   client SubjectPublicKeyInfo via an out-of-band method.




Wouters, et al.              Standards Track                    [Page 9]
   __________________________________________________________________


RFC 7250            Using Raw Public Keys in TLS/DTLS          June 2014


5.  Examples

   Figures 6, 7, and 8 illustrate example exchanges.  Note that TLS
   ciphersuites using a Diffie-Hellman exchange offering forward secrecy
   can be used with a raw public key, although this document does not
   show the information exchange at that level with the subsequent
   message flows.

5.1.  TLS Server Uses a Raw Public Key

   This section shows an example where the TLS client indicates its
   ability to receive and validate a raw public key from the server.  In
   this example, the client is quite restricted since it is unable to
   process other certificate types sent by the server.  It also does not
   have credentials at the TLS layer it could send to the server and
   therefore omits the client_certificate_type extension.  Hence, the
   client only populates the server_certificate_type extension with the
   raw public key type, as shown in (1).

   When the TLS server receives the client hello, it processes the
   extension.  Since it has a raw public key, it indicates in (2) that
   it had chosen to place the SubjectPublicKeyInfo structure into the
   Certificate payload (3).

   The client uses this raw public key in the TLS handshake together
   with an out-of-band validation technique, such as DANE, to verify it.

  client_hello,
  server_certificate_type=(RawPublicKey) // (1)
                         ->
                         <- server_hello,
                            server_certificate_type=RawPublicKey, // (2)
                            certificate, // (3)
                            server_key_exchange,
                            server_hello_done

  client_key_exchange,
  change_cipher_spec,
  finished               ->

                         <- change_cipher_spec,
                            finished

  Application Data       <-------> Application Data

     Figure 6: Example with Raw Public Key Provided by the TLS Server





Wouters, et al.              Standards Track                   [Page 10]
   __________________________________________________________________


RFC 7250            Using Raw Public Keys in TLS/DTLS          June 2014


5.2.  TLS Client and Server Use Raw Public Keys

   This section shows an example where the TLS client as well as the TLS
   server use raw public keys.  This is one of the use cases envisioned
   for smart object networking.  The TLS client in this case is an
   embedded device that is configured with a raw public key for use with
   TLS and is also able to process a raw public key sent by the server.
   Therefore, it indicates these capabilities in (1).  As in the
   previously shown example, the server fulfills the client's request,
   indicates this via the RawPublicKey value in the
   server_certificate_type payload (2), and provides a raw public key in
   the Certificate payload back to the client (see (3)).  The TLS server
   demands client authentication, and therefore includes a
   certificate_request (4).  The client_certificate_type payload in (5)
   indicates that the TLS server accepts a raw public key.  The TLS
   client, which has a raw public key pre-provisioned, returns it in the
   Certificate payload (6) to the server.

client_hello,
client_certificate_type=(RawPublicKey) // (1)
server_certificate_type=(RawPublicKey) // (1)
                         ->
                         <-  server_hello,
                             server_certificate_type=RawPublicKey // (2)
                             certificate, // (3)
                             client_certificate_type=RawPublicKey // (5)
                             certificate_request, // (4)
                             server_key_exchange,
                             server_hello_done

certificate, // (6)
client_key_exchange,
change_cipher_spec,
finished                  ->

                         <- change_cipher_spec,
                            finished

Application Data        <------->     Application Data

   Figure 7: Example with Raw Public Key provided by the TLS Server and
                                the Client









Wouters, et al.              Standards Track                   [Page 11]
   __________________________________________________________________


RFC 7250            Using Raw Public Keys in TLS/DTLS          June 2014


5.3.  Combined Usage of Raw Public Keys and X.509 Certificates

   This section shows an example combining a raw public key and an X.509
   certificate.  The client uses a raw public key for client
   authentication, and the server provides an X.509 certificate.  This
   exchange starts with the client indicating its ability to process an
   X.509 certificate, OpenPGP certificate, or a raw public key, if
   provided by the server.  It prefers a raw public key, since the
   RawPublicKey value precedes the other values in the
   server_certificate_type vector.  Additionally, the client indicates
   that it has a raw public key for client-side authentication (see
   (1)).  The server chooses to provide its X.509 certificate in (3) and
   indicates that choice in (2).  For client authentication, the server
   indicates in (4) that it has selected the raw public key format and
   requests a certificate from the client in (5).  The TLS client
   provides a raw public key in (6) after receiving and processing the
   TLS server hello message.

client_hello,
server_certificate_type=(RawPublicKey, X.509, OpenPGP)
client_certificate_type=(RawPublicKey) // (1)
                         ->
                         <-  server_hello,
                             server_certificate_type=X.509 // (2)
                             certificate, // (3)
                             client_certificate_type=RawPublicKey // (4)
                             certificate_request, // (5)
                             server_key_exchange,
                             server_hello_done
certificate, // (6)
client_key_exchange,
change_cipher_spec,
finished                  ->

                          <- change_cipher_spec,
                             finished

Application Data        <------->     Application Data

                   Figure 8: Hybrid Certificate Example











Wouters, et al.              Standards Track                   [Page 12]
   __________________________________________________________________


RFC 7250            Using Raw Public Keys in TLS/DTLS          June 2014


6.  Security Considerations

   The transmission of raw public keys, as described in this document,
   provides benefits by lowering the over-the-air transmission overhead
   since raw public keys are naturally smaller than an entire
   certificate.  There are also advantages from a code-size point of
   view for parsing and processing these keys.  The cryptographic
   procedures for associating the public key with the possession of a
   private key also follows standard procedures.

   However, the main security challenge is how to associate the public
   key with a specific entity.  Without a secure binding between
   identifier and key, the protocol will be vulnerable to man-in-the-
   middle attacks.  This document assumes that such binding can be made
   out-of-band, and we list a few examples in Section 1.  DANE [RFC6698]
   offers one such approach.  In order to address these vulnerabilities,
   specifications that make use of the extension need to specify how the
   identifier and public key are bound.  In addition to ensuring the
   binding is done out-of-band, an implementation also needs to check
   the status of that binding.

   If public keys are obtained using DANE, these public keys are
   authenticated via DNSSEC.  Using pre-configured keys is another out-
   of-band method for authenticating raw public keys.  While pre-
   configured keys are not suitable for a generic Web-based e-commerce
   environment, such keys are a reasonable approach for many smart
   object deployments where there is a close relationship between the
   software running on the device and the server-side communication
   endpoint.  Regardless of the chosen mechanism for out-of-band public
   key validation, an assessment of the most suitable approach has to be
   made prior to the start of a deployment to ensure the security of the
   system.

   An attacker might try to influence the handshake exchange to make the
   parties select different certificate types than they would normally
   choose.

   For this attack, an attacker must actively change one or more
   handshake messages.  If this occurs, the client and server will
   compute different values for the handshake message hashes.  As a
   result, the parties will not accept each others' Finished messages.
   Without the master_secret, the attacker cannot repair the Finished
   messages, so the attack will be discovered.








Wouters, et al.              Standards Track                   [Page 13]
   __________________________________________________________________


RFC 7250            Using Raw Public Keys in TLS/DTLS          June 2014


7.  IANA Considerations

   IANA has registered a new value in the "TLS Certificate Types"
   subregistry of the "Transport Layer Security (TLS) Extensions"
   registry [TLS-Ext-Registry], as follows:

   Value: 2
   Description: Raw Public Key
   Reference: RFC 7250

   IANA has allocated two new TLS extensions, client_certificate_type
   and server_certificate_type, from the "TLS ExtensionType Values"
   subregistry defined in [RFC5246].  These extensions are used in both
   the client hello message and the server hello message.  The new
   extension types are used for certificate type negotiation.  The
   values carried in these extensions are taken from the "TLS
   Certificate Types" subregistry of the "Transport Layer Security (TLS)
   Extensions" registry [TLS-Ext-Registry].

8.  Acknowledgements

   The feedback from the TLS working group meeting at IETF 81 has
   substantially shaped the document, and we would like to thank the
   meeting participants for their input.  The support for hashes of
   public keys has been moved to [CACHED-INFO] after the discussions at
   the IETF 82 meeting.

   We would like to thank the following persons for their review
   comments: Martin Rex, Bill Frantz, Zach Shelby, Carsten Bormann,
   Cullen Jennings, Rene Struik, Alper Yegin, Jim Schaad, Barry Leiba,
   Paul Hoffman, Robert Cragie, Nikos Mavrogiannopoulos, Phil Hunt, John
   Bradley, Klaus Hartke, Stefan Jucker, Kovatsch Matthias, Daniel Kahn
   Gillmor, Peter Sylvester, Hauke Mehrtens, Alexey Melnikov, Stephen
   Farrell, Richard Barnes, and James Manger.  Nikos Mavrogiannopoulos
   contributed the design for reusing the certificate type registry.
   Barry Leiba contributed guidance for the IANA Considerations text.
   Stefan Jucker, Kovatsch Matthias, and Klaus Hartke provided
   implementation feedback regarding the SubjectPublicKeyInfo structure.

   Christer Holmberg provided the General Area (Gen-Art) review, Yaron
   Sheffer provided the Security Directorate (SecDir) review, Bert
   Greevenbosch provided the Applications Area Directorate review, and
   Linda Dunbar provided the Operations Directorate review.

   We would like to thank our TLS working group chairs, Eric Rescorla
   and Joe Salowey, for their guidance and support.  Finally, we would
   like to thank Sean Turner, who is the responsible Security Area
   Director for this work, for his review comments and suggestions.



Wouters, et al.              Standards Track                   [Page 14]
   __________________________________________________________________


RFC 7250            Using Raw Public Keys in TLS/DTLS          June 2014


9.  References

9.1.  Normative References

   [PKIX]     Cooper, D., Santesson, S., Farrell, S., Boeyen, S.,
              Housley, R., and W. Polk, "Internet X.509 Public Key
              Infrastructure Certificate and Certificate Revocation List
              (CRL) Profile", RFC 5280, May 2008.

   [RFC2119]  Bradner, S., "Key words for use in RFCs to Indicate
              Requirement Levels", BCP 14, RFC 2119, March 1997.

   [RFC3279]  Bassham, L., Polk, W., and R. Housley, "Algorithms and
              Identifiers for the Internet X.509 Public Key
              Infrastructure Certificate and Certificate Revocation List
              (CRL) Profile", RFC 3279, April 2002.

   [RFC5246]  Dierks, T. and E. Rescorla, "The Transport Layer Security
              (TLS) Protocol Version 1.2", RFC 5246, August 2008.

   [RFC5480]  Turner, S., Brown, D., Yiu, K., Housley, R., and T. Polk,
              "Elliptic Curve Cryptography Subject Public Key
              Information", RFC 5480, March 2009.

   [TLS-Ext-Registry]
              IANA, "Transport Layer Security (TLS) Extensions",
              <http://www.iana.org/assignments/
              tls-extensiontype-values>.

   [X.690]    ITU-T, "Information technology - ASN.1 encoding rules:
              Specification of Basic Encoding Rules (BER), Canonical
              Encoding Rules (CER) and Distinguished Encoding Rules
              (DER)", ITU-T Recommendation X.690, ISO/IEC 8825-1:2002,
              2002.

9.2.  Informative References

   [ASN.1-Dump]
              Gutmann, P., "ASN.1 Object Dump Program", February 2013,
              <http://www.cs.auckland.ac.nz/~pgut001/>.

   [CACHED-INFO]
              Santesson, S. and H. Tschofenig, "Transport Layer Security
              (TLS) Cached Information Extension", Work in Progress,
              February 2014.

   [CoAP]     Shelby, Z., Hartke, K., and C. Bormann, "The Constrained
              Application Protocol (CoAP)", RFC 7252, June 2014.



Wouters, et al.              Standards Track                   [Page 15]
   __________________________________________________________________


RFC 7250            Using Raw Public Keys in TLS/DTLS          June 2014


   [Defeating-SSL]
              Marlinspike, M., "New Tricks for Defeating SSL in
              Practice", February 2009, <http://www.blackhat.com/
              presentations/bh-dc-09/Marlinspike/
              BlackHat-DC-09-Marlinspike-Defeating-SSL.pdf>.

   [LDAP]     Sermersheim, J., "Lightweight Directory Access Protocol
              (LDAP): The Protocol", RFC 4511, June 2006.

   [RFC6698]  Hoffman, P. and J. Schlyter, "The DNS-Based Authentication
              of Named Entities (DANE) Transport Layer Security (TLS)
              Protocol: TLSA", RFC 6698, August 2012.







































Wouters, et al.              Standards Track                   [Page 16]
   __________________________________________________________________


RFC 7250            Using Raw Public Keys in TLS/DTLS          June 2014


Appendix A.  Example Encoding

   For example, the hex sequence shown in Figure 9 describes a
   SubjectPublicKeyInfo structure inside the certificate payload.

          0     1     2     3     4     5     6     7     8     9
      +------+-----+-----+-----+-----+-----+-----+-----+-----+-----
   1  | 0x30, 0x81, 0x9f, 0x30, 0x0d, 0x06, 0x09, 0x2a, 0x86, 0x48,
   2  | 0x86, 0xf7, 0x0d, 0x01, 0x01, 0x01, 0x05, 0x00, 0x03, 0x81,
   3  | 0x8d, 0x00, 0x30, 0x81, 0x89, 0x02, 0x81, 0x81, 0x00, 0xcd,
   4  | 0xfd, 0x89, 0x48, 0xbe, 0x36, 0xb9, 0x95, 0x76, 0xd4, 0x13,
   5  | 0x30, 0x0e, 0xbf, 0xb2, 0xed, 0x67, 0x0a, 0xc0, 0x16, 0x3f,
   6  | 0x51, 0x09, 0x9d, 0x29, 0x2f, 0xb2, 0x6d, 0x3f, 0x3e, 0x6c,
   7  | 0x2f, 0x90, 0x80, 0xa1, 0x71, 0xdf, 0xbe, 0x38, 0xc5, 0xcb,
   8  | 0xa9, 0x9a, 0x40, 0x14, 0x90, 0x0a, 0xf9, 0xb7, 0x07, 0x0b,
   9  | 0xe1, 0xda, 0xe7, 0x09, 0xbf, 0x0d, 0x57, 0x41, 0x86, 0x60,
   10 | 0xa1, 0xc1, 0x27, 0x91, 0x5b, 0x0a, 0x98, 0x46, 0x1b, 0xf6,
   11 | 0xa2, 0x84, 0xf8, 0x65, 0xc7, 0xce, 0x2d, 0x96, 0x17, 0xaa,
   12 | 0x91, 0xf8, 0x61, 0x04, 0x50, 0x70, 0xeb, 0xb4, 0x43, 0xb7,
   13 | 0xdc, 0x9a, 0xcc, 0x31, 0x01, 0x14, 0xd4, 0xcd, 0xcc, 0xc2,
   14 | 0x37, 0x6d, 0x69, 0x82, 0xd6, 0xc6, 0xc4, 0xbe, 0xf2, 0x34,
   15 | 0xa5, 0xc9, 0xa6, 0x19, 0x53, 0x32, 0x7a, 0x86, 0x0e, 0x91,
   16 | 0x82, 0x0f, 0xa1, 0x42, 0x54, 0xaa, 0x01, 0x02, 0x03, 0x01,
   17 | 0x00, 0x01

      Figure 9: Example SubjectPublicKeyInfo Structure Byte Sequence

   The decoded byte sequence shown in Figure 9 (for example, using Peter
   Gutmann's ASN.1 decoder [ASN.1-Dump]) illustrates the structure, as
   shown in Figure 10.

   Offset  Length   Description
   -------------------------------------------------------------------
      0     3+159:   SEQUENCE {
      3      2+13:     SEQUENCE {
      5       2+9:      OBJECT IDENTIFIER Value (1 2 840 113549 1 1 1)
                 :             PKCS #1, rsaEncryption
     16       2+0:      NULL
                 :      }
     18     3+141:    BIT STRING, encapsulates {
     22     3+137:      SEQUENCE {
     25     3+129:        INTEGER Value (1024 bit)
    157       2+3:        INTEGER Value (65537)
                 :        }
                 :      }
                 :    }

       Figure 10: Decoding of Example SubjectPublicKeyInfo Structure



Wouters, et al.              Standards Track                   [Page 17]
   __________________________________________________________________


RFC 7250            Using Raw Public Keys in TLS/DTLS          June 2014


Authors' Addresses

   Paul Wouters (editor)
   Red Hat

   EMail: pwouters@redhat.com


   Hannes Tschofenig (editor)
   ARM Ltd.
   6060 Hall in Tirol
   Austria

   EMail: Hannes.tschofenig@gmx.net
   URI:   http://www.tschofenig.priv.at


   John Gilmore
   Electronic Frontier Foundation
   PO Box 170608
   San Francisco, California  94117
   USA

   Phone: +1 415 221 6524
   EMail: gnu@toad.com
   URI:   https://www.toad.com/


   Samuel Weiler
   Parsons
   7110 Samuel Morse Drive
   Columbia, Maryland  21046
   US

   EMail: weiler@tislabs.com


   Tero Kivinen
   INSIDE Secure
   Eerikinkatu 28
   Helsinki  FI-00180
   FI

   EMail: kivinen@iki.fi







Wouters, et al.              Standards Track                   [Page 18]


   Html markup produced by rfcmarkup 1.129c, available from
   https://tools.ietf.org/tools/rfcmarkup/
   [Docs] [txt|pdf] [draft-ietf-tls-...] [Tracker] [Diff1] [Diff2]
   PROPOSED STANDARD
Internet Engineering Task Force (IETF)                      S. Santesson
Request for Comments: 7924                               3xA Security AB
Category: Standards Track                                  H. Tschofenig
ISSN: 2070-1721                                                 ARM Ltd.
                                                               July 2016


      Transport Layer Security (TLS) Cached Information Extension

Abstract

   Transport Layer Security (TLS) handshakes often include fairly static
   information, such as the server certificate and a list of trusted
   certification authorities (CAs).  This information can be of
   considerable size, particularly if the server certificate is bundled
   with a complete certificate chain (i.e., the certificates of
   intermediate CAs up to the root CA).

   This document defines an extension that allows a TLS client to inform
   a server of cached information, thereby enabling the server to omit
   already available information.

Status of This Memo

   This is an Internet Standards Track document.

   This document is a product of the Internet Engineering Task Force
   (IETF).  It represents the consensus of the IETF community.  It has
   received public review and has been approved for publication by the
   Internet Engineering Steering Group (IESG).  Further information on
   Internet Standards is available in Section 2 of RFC 7841.

   Information about the current status of this document, any errata,
   and how to provide feedback on it may be obtained at
   http://www.rfc-editor.org/info/rfc7924.
















Santesson & Tschofenig       Standards Track                    [Page 1]
   __________________________________________________________________


RFC 7924            TLS Cached Information Extension           July 2016


Copyright Notice

   Copyright (c) 2016 IETF Trust and the persons identified as the
   document authors.  All rights reserved.

   This document is subject to BCP 78 and the IETF Trust's Legal
   Provisions Relating to IETF Documents
   (http://trustee.ietf.org/license-info) in effect on the date of
   publication of this document.  Please review these documents
   carefully, as they describe your rights and restrictions with respect
   to this document.  Code Components extracted from this document must
   include Simplified BSD License text as described in Section 4.e of
   the Trust Legal Provisions and are provided without warranty as
   described in the Simplified BSD License.

Table of Contents

   1.  Introduction  . . . . . . . . . . . . . . . . . . . . . . . .   3
   2.  Terminology . . . . . . . . . . . . . . . . . . . . . . . . .   3
   3.  Cached Information Extension  . . . . . . . . . . . . . . . .   3
   4.  Exchange Specification  . . . . . . . . . . . . . . . . . . .   5
     4.1.  Server Certificate Message  . . . . . . . . . . . . . . .   6
     4.2.  CertificateRequest Message  . . . . . . . . . . . . . . .   7
   5.  Fingerprint Calculation . . . . . . . . . . . . . . . . . . .   7
   6.  Example . . . . . . . . . . . . . . . . . . . . . . . . . . .   8
   7.  Security Considerations . . . . . . . . . . . . . . . . . . .  10
   8.  IANA Considerations . . . . . . . . . . . . . . . . . . . . .  10
     8.1.  New Entry to the TLS ExtensionType Registry . . . . . . .  10
     8.2.  New Registry for CachedInformationType  . . . . . . . . .  11
   9.  References  . . . . . . . . . . . . . . . . . . . . . . . . .  11
     9.1.  Normative References  . . . . . . . . . . . . . . . . . .  11
     9.2.  Informative References  . . . . . . . . . . . . . . . . .  12
   Appendix A.  Example  . . . . . . . . . . . . . . . . . . . . . .  13
   Acknowledgments . . . . . . . . . . . . . . . . . . . . . . . . .  18
   Authors' Addresses  . . . . . . . . . . . . . . . . . . . . . . .  19
















Santesson & Tschofenig       Standards Track                    [Page 2]
   __________________________________________________________________


RFC 7924            TLS Cached Information Extension           July 2016


1.  Introduction

   Reducing the amount of information exchanged during a Transport Layer
   Security handshake to a minimum helps to improve performance in
   environments where devices are connected to a network with a low
   bandwidth and lossy radio technology.  With the Internet of Things,
   such environments exist, for example, when devices use IEEE 802.15.4,
   Bluetooth Low Energy, or low power wide area networks.  For more
   information about the challenges with smart object deployments,
   please see [RFC6574].

   This specification defines a TLS extension that allows a client and a
   server to exclude transmission information cached in an earlier TLS
   handshake.

   A typical example exchange may therefore look as follows.  First, the
   client and the server execute the full TLS handshake.  The client
   then caches the certificate provided by the server.  When the TLS
   client connects to the TLS server some time in the future, without
   using session resumption, it then attaches the "cached_info"
   extension defined in this document to the ClientHello message to
   indicate that it has cached the certificate, and it provides the
   fingerprint of it.  If the server's certificate has not changed, then
   the TLS server does not need to send its certificate and the
   corresponding certificate chain again.  In case information has
   changed, which can be seen from the fingerprint provided by the
   client, the certificate payload is transmitted to the client to allow
   the client to update the cache.

2.  Terminology

   The key words "MUST", "MUST NOT", "REQUIRED", "MUST", "MUST NOT",
   "SHOULD", "SHOULD NOT", "RECOMMENDED", "MAY", and "OPTIONAL" in this
   document are to be interpreted as described in [RFC2119].

   This document refers to the TLS protocol, but the description is
   equally applicable to Datagram Transport Layer Security (DTLS) as
   well.

3.  Cached Information Extension

   This document defines a new extension type (cached_info(25)), which
   is used in ClientHello and ServerHello messages.  The extension type
   is specified as follows.

         enum {
              cached_info(25), (65535)
         } ExtensionType;



Santesson & Tschofenig       Standards Track                    [Page 3]
   __________________________________________________________________


RFC 7924            TLS Cached Information Extension           July 2016


   The extension_data field of this extension, when included in the
   ClientHello, MUST contain the CachedInformation structure.  The
   client MAY send multiple CachedObjects of the same
   CachedInformationType.  This may, for example, be the case when the
   client has cached multiple certificates from a server.

         enum {
              cert(1), cert_req(2) (255)
         } CachedInformationType;

         struct {
              select (type) {
                case client:
                  CachedInformationType type;
                  opaque hash_value<1..255>;
                case server:
                  CachedInformationType type;
              } body;
         } CachedObject;

         struct {
              CachedObject cached_info<1..2^16-1>;
         } CachedInformation;

   This document defines the following two types:

   'cert' type for not sending the complete server certificate message:

      With the type field set to 'cert', the client MUST include the
      fingerprint of the Certificate message in the hash_value field.
      For this type, the fingerprint MUST be calculated using the
      procedure described in Section 5 with the Certificate message as
      input data.

   'cert_req' Type for not sending the complete CertificateRequest
      Message:

      With the type set to 'cert_req', the client MUST include the
      fingerprint of the CertificateRequest message in the hash_value
      field.  For this type, the fingerprint MUST be calculated using
      the procedure described in Section 5 with the CertificateRequest
      message as input data.

   New cached info types can be added following the policy described in
   the IANA Considerations (Section 8).  New message digest algorithms
   for use with these types can also be added by registering a new type
   that makes use of the updated message digest algorithm.  For
   practical reasons, we recommend reusing hash algorithms already



Santesson & Tschofenig       Standards Track                    [Page 4]
   __________________________________________________________________


RFC 7924            TLS Cached Information Extension           July 2016


   available with TLS ciphersuites.  To avoid additional code and to
   keep the collision probability low, new hash algorithms MUST NOT have
   a collision resistance worse than SHA-256.

4.  Exchange Specification

   Clients supporting this extension MAY include the "cached_info"
   extension in the (extended) ClientHello.  If the client includes the
   extension, then it MUST contain one or more CachedObject attributes.

   A server supporting this extension MAY include the "cached_info"
   extension in the (extended) ServerHello.  By returning the
   "cached_info" extension, the server indicates that it supports the
   cached info types.  For each indicated cached info type, the server
   MUST alter the transmission of respective payloads, according to the
   rules outlined with each type.  If the server includes the extension,
   it MUST only include CachedObjects of a type also supported by the
   client (as expressed in the ClientHello).  For example, if a client
   indicates support for 'cert' and 'cert_req', then the server cannot
   respond with a "cached_info" attribute containing support for
   ('foo-bar').

   Since the client includes a fingerprint of information it cached (for
   each indicated type), the server is able to determine whether cached
   information is stale.  If the server supports this specification and
   notices a mismatch between the data cached by the client and its own
   information, then the server MUST include the information in full and
   MUST NOT list the respective type in the "cached_info" extension.

   Note: If a server is part of a hosting environment, then the client
   may have cached multiple data items for a single server.  To allow
   the client to select the appropriate information from the cache, it
   is RECOMMENDED that the client utilizes the Server Name Indication
   (SNI) extension [RFC6066].

   Following a successful exchange of the "cached_info" extension in the
   ClientHello and ServerHello, the server alters sending the
   corresponding handshake message.  How information is altered from the
   handshake messages and for the types defined in this specification is
   defined in Sections 4.1 and 4.2, respectively.

   Appendix A shows an example hash calculation, and Section 6
   illustrates an example protocol exchange.








Santesson & Tschofenig       Standards Track                    [Page 5]
   __________________________________________________________________


RFC 7924            TLS Cached Information Extension           July 2016


4.1.  Server Certificate Message

   When a ClientHello message contains the "cached_info" extension with
   a type set to 'cert', then the server MAY send the Certificate
   message shown in Figure 1 under the following conditions:

   o  The server software implements the "cached_info" extension defined
      in this specification.

   o  The 'cert' "cached_info" extension is enabled (for example, a
      policy allows the use of this extension).

   o  The server compared the value in the hash_value field of the
      client-provided "cached_info" extension with the fingerprint of
      the Certificate message it normally sends to clients.  This check
      ensures that the information cached by the client is current.  The
      procedure for calculating the fingerprint is described in
      Section 5.

   The original certificate handshake message syntax is defined in
   [RFC5246] and has been extended with [RFC7250].  RFC 7250 allows the
   certificate payload to contain only the SubjectPublicKeyInfo instead
   of the full information typically found in a certificate.  Hence,
   when this specification is used in combination with [RFC7250] and the
   negotiated certificate type is a raw public key, then the TLS server
   omits sending a certificate payload that contains an ASN.1
   certificate structure with the included SubjectPublicKeyInfo rather
   than the full certificate chain.  As such, this extension is
   compatible with the raw public key extension defined in RFC 7250.
   Note: We assume that the server implementation is able to select the
   appropriate certificate or SubjectPublicKeyInfo from the received
   hash value.  If the SNI extension is used by the client, then the
   server has additional information to guide the selection of the
   appropriate cached info.

   When the cached info specification is used, then a modified version
   of the Certificate message is exchanged.  The modified structure is
   shown in Figure 1.

         struct {
             opaque hash_value<1..255>;
         } Certificate;

                 Figure 1: Cached Info Certificate Message







Santesson & Tschofenig       Standards Track                    [Page 6]
   __________________________________________________________________


RFC 7924            TLS Cached Information Extension           July 2016


4.2.  CertificateRequest Message

   When a fingerprint for an object of type 'cert_req' is provided in
   the ClientHello, the server MAY send the CertificateRequest message
   shown in Figure 2 under the following conditions:

   o  The server software implements the "cached_info" extension defined
      in this specification.

   o  The 'cert_req' "cached_info" extension is enabled (for example, a
      policy allows the use of this extension).

   o  The server compared the value in the hash_value field of the
      client-provided "cached_info" extension with the fingerprint of
      the CertificateRequest message it normally sends to clients.  This
      check ensures that the information cached by the client is
      current.  The procedure for calculating the fingerprint is
      described in Section 5.

   o  The server wants to request a certificate from the client.

   The original CertificateRequest handshake message syntax is defined
   in [RFC5246].  The modified structure of the CertificateRequest
   message is shown in Figure 2.

         struct {
             opaque hash_value<1..255>;
         } CertificateRequest;

             Figure 2: Cached Info CertificateRequest Message

   The CertificateRequest payload is the input parameter to the
   fingerprint calculation described in Section 5.

5.  Fingerprint Calculation

   The fingerprint for the two cached info objects defined in this
   document MUST be computed as follows:

   1.  Compute the SHA-256 [RFC6234] hash of the input data.  The input
       data depends on the cached info type.  This document defines two
       cached info types, described in Sections 4.1 and in 4.2.  Note
       that the computed hash only covers the input data structure (and
       not any type and length information of the record layer).
       Appendix A shows an example.

   2.  Use the output of the SHA-256 hash.




Santesson & Tschofenig       Standards Track                    [Page 7]
   __________________________________________________________________


RFC 7924            TLS Cached Information Extension           July 2016


   The purpose of the fingerprint provided by the client is to help the
   server select the correct information.  For example, in case of a
   Certificate message, the fingerprint identifies the server
   certificate (and the corresponding private key) for use with the rest
   of the handshake.  Servers may have more than one certificate, and
   therefore a hash needs to be long enough to keep the probably of hash
   collisions low.  On the other hand, the cached info design aims to
   reduce the amount of data being exchanged.  The security of the
   handshake depends on the private key and not on the size of the
   fingerprint.  Hence, the fingerprint is a way to prevent the server
   from accidentally selecting the wrong information.  If an attacker
   injects an incorrect fingerprint, then two outcomes are possible: (1)
   the fingerprint does not relate to any cached state and the server
   has to fall back to a full exchange, and (2) if the attacker manages
   to inject a fingerprint that refers to data the client has not
   cached, then the exchange will fail later when the client continues
   with the handshake and aims to verify the digital signature.  The
   signature verification will fail since the public key cached by the
   client will not correspond to the private key that was used by the
   server to sign the message.

6.  Example

   In the regular, full TLS handshake exchange, shown in Figure 3, the
   TLS server provides its certificate in the certificate payload to the
   client; see step (1).  This allows the client to store the
   certificate for future use.  After some time, the TLS client again
   interacts with the same TLS server and makes use of the TLS
   "cached_info" extension, as shown in Figure 4.  The TLS client
   indicates support for this specification via the "cached_info"
   extension, see step (2), and indicates that it has stored the
   certificate from the earlier exchange (by indicating the 'cert'
   type).  With step (3), the TLS server acknowledges the support of the
   'cert' type and by including the value in the ServerHello, it informs
   the client that the content of the certificate payload contains the
   fingerprint of the certificate instead of the payload, defined in RFC
   5246, of the Certificate message; see step (4).














Santesson & Tschofenig       Standards Track                    [Page 8]
   __________________________________________________________________


RFC 7924            TLS Cached Information Extension           July 2016


   ClientHello            ->
                          <-  ServerHello
                              Certificate* // (1)
                              ServerKeyExchange*
                              CertificateRequest*
                              ServerHelloDone

   Certificate*
   ClientKeyExchange
   CertificateVerify*
   [ChangeCipherSpec]
   Finished               ->

                          <- [ChangeCipherSpec]
                             Finished

   Application Data <-------> Application Data

        Figure 3: Example Message Exchange: Initial (Full) Exchange


   ClientHello
   cached_info=(cert)     -> // (2)
                          <-  ServerHello
                              cached_info=(cert) (3)
                              Certificate (4)
                              ServerKeyExchange*
                              ServerHelloDone

   ClientKeyExchange
   CertificateVerify*
   [ChangeCipherSpec]
   Finished               ->

                          <- [ChangeCipherSpec]
                             Finished

   Application Data <-------> Application Data

      Figure 4: Example Message Exchange: TLS Cached Extension Usage











Santesson & Tschofenig       Standards Track                    [Page 9]
   __________________________________________________________________


RFC 7924            TLS Cached Information Extension           July 2016


7.  Security Considerations

   This specification defines a mechanism to reference stored state
   using a fingerprint.  Sending a fingerprint of cached information in
   an unencrypted handshake, as the ClientHello and ServerHello does,
   may allow an attacker or observer to correlate independent TLS
   exchanges.  While some information elements used in this
   specification, such as server certificates, are public objects and
   usually do not contain sensitive information, other types that are
   not yet defined may.  Those who implement and deploy this
   specification should therefore make an informed decision whether the
   cached information is in line with their security and privacy goals.
   In case of concerns, it is advised to avoid sending the fingerprint
   of the data objects in clear.

   The use of the "cached_info" extension allows the server to send
   significantly smaller TLS messages.  Consequently, these omitted
   parts of the messages are not included in the transcript of the
   handshake in the TLS Finish message.  However, since the client and
   the server communicate the hash values of the cached data in the
   initial handshake messages, the fingerprints are included in the TLS
   Finish message.

   Clients MUST ensure that they only cache information from legitimate
   sources.  For example, when the client populates the cache from a TLS
   exchange, then it must only cache information after the successful
   completion of a TLS exchange to ensure that an attacker does not
   inject incorrect information into the cache.  Failure to do so allows
   for man-in-the-middle attacks.

   Security considerations for the fingerprint calculation are discussed
   in Section 5.

8.  IANA Considerations

8.1.  New Entry to the TLS ExtensionType Registry

   IANA has added an entry to the existing TLS "ExtensionType Values"
   registry, defined in [RFC5246], for cached_info(25) defined in this
   document.











Santesson & Tschofenig       Standards Track                   [Page 10]
   __________________________________________________________________


RFC 7924            TLS Cached Information Extension           July 2016


8.2.  New Registry for CachedInformationType

   IANA has established a registry titled "TLS CachedInformationType
   Values".  The entries in the registry are:

   Value    Description
   -----    -----------
     0      Reserved
     1      cert
     2      cert_req
   224-255  Reserved for Private Use

   The policy for adding new values to this registry, following the
   terminology defined in [RFC5226], is as follows:

   o  0-63 (decimal): Standards Action

   o  64-223 (decimal): Specification Required

9.  References

9.1.  Normative References

   [RFC2119]  Bradner, S., "Key words for use in RFCs to Indicate
              Requirement Levels", BCP 14, RFC 2119,
              DOI 10.17487/RFC2119, March 1997,
              <http://www.rfc-editor.org/info/rfc2119>.

   [RFC5246]  Dierks, T. and E. Rescorla, "The Transport Layer Security
              (TLS) Protocol Version 1.2", RFC 5246,
              DOI 10.17487/RFC5246, August 2008,
              <http://www.rfc-editor.org/info/rfc5246>.

   [RFC6066]  Eastlake 3rd, D., "Transport Layer Security (TLS)
              Extensions: Extension Definitions", RFC 6066,
              DOI 10.17487/RFC6066, January 2011,
              <http://www.rfc-editor.org/info/rfc6066>.

   [RFC6234]  Eastlake 3rd, D. and T. Hansen, "US Secure Hash Algorithms
              (SHA and SHA-based HMAC and HKDF)", RFC 6234,
              DOI 10.17487/RFC6234, May 2011,
              <http://www.rfc-editor.org/info/rfc6234>.









Santesson & Tschofenig       Standards Track                   [Page 11]
   __________________________________________________________________


RFC 7924            TLS Cached Information Extension           July 2016


9.2.  Informative References

   [ASN.1-Dump]
              Gutmann, P., "ASN.1 Object Dump Program", November 2010,
              <http://manpages.ubuntu.com/manpages/precise/man1/
              dumpasn1.1.html>.

   [RFC5226]  Narten, T. and H. Alvestrand, "Guidelines for Writing an
              IANA Considerations Section in RFCs", BCP 26, RFC 5226,
              DOI 10.17487/RFC5226, May 2008,
              <http://www.rfc-editor.org/info/rfc5226>.

   [RFC6574]  Tschofenig, H. and J. Arkko, "Report from the Smart Object
              Workshop", RFC 6574, DOI 10.17487/RFC6574, April 2012,
              <http://www.rfc-editor.org/info/rfc6574>.

   [RFC7250]  Wouters, P., Ed., Tschofenig, H., Ed., Gilmore, J.,
              Weiler, S., and T. Kivinen, "Using Raw Public Keys in
              Transport Layer Security (TLS) and Datagram Transport
              Layer Security (DTLS)", RFC 7250, DOI 10.17487/RFC7250,
              June 2014, <http://www.rfc-editor.org/info/rfc7250>.






























Santesson & Tschofenig       Standards Track                   [Page 12]
   __________________________________________________________________


RFC 7924            TLS Cached Information Extension           July 2016


Appendix A.  Example

   Consider a certificate containing a NIST P256 elliptic curve public
   key displayed using Peter Gutmann's ASN.1 decoder [ASN.1-Dump] in
   Figure 5.

    0 556: SEQUENCE {
    4 434:   SEQUENCE {
    8   3:     [0] {
   10   1:       INTEGER 2
         :       }
   13   1:     INTEGER 13
   16  10:     SEQUENCE {
   18   8:      OBJECT IDENTIFIER ecdsaWithSHA256 (1 2 840 10045 4 3 2)
         :       }
   28  62:     SEQUENCE {
   30  11:       SET {
   32   9:         SEQUENCE {
   34   3:           OBJECT IDENTIFIER countryName (2 5 4 6)
   39   2:           PrintableString 'NL'
         :           }
         :         }
   43  17:       SET {
   45  15:         SEQUENCE {
   47   3:           OBJECT IDENTIFIER organizationName (2 5 4 10)
   52   8:           PrintableString 'PolarSSL'
         :           }
         :         }
   62  28:       SET {
   64  26:         SEQUENCE {
   66   3:           OBJECT IDENTIFIER commonName (2 5 4 3)
   71  19:           PrintableString 'Polarssl Test EC CA'
         :           }
         :         }
         :       }
   92  30:     SEQUENCE {
   94  13:       UTCTime 24/09/2013 15:52:04 GMT
  109  13:       UTCTime 22/09/2023 15:52:04 GMT
         :       }
  124  65:     SEQUENCE {
  126  11:       SET {
  128   9:         SEQUENCE {
  130   3:           OBJECT IDENTIFIER countryName (2 5 4 6)
  135   2:           PrintableString 'NL'
         :           }
         :         }





Santesson & Tschofenig       Standards Track                   [Page 13]
   __________________________________________________________________


RFC 7924            TLS Cached Information Extension           July 2016


  139  17:       SET {
  141  15:         SEQUENCE {
  143   3:           OBJECT IDENTIFIER organizationName (2 5 4 10)
  148   8:           PrintableString 'PolarSSL'
         :           }
         :         }
  158  31:       SET {
  160  29:         SEQUENCE {
  162   3:           OBJECT IDENTIFIER commonName (2 5 4 3)
  167  22:           PrintableString 'PolarSSL Test Client 2'
         :           }
         :         }
         :       }
  191  89:     SEQUENCE {
  193  19:       SEQUENCE {
  195   7:         OBJECT IDENTIFIER ecPublicKey (1 2 840 10045 2 1)
  204   8:         OBJECT IDENTIFIER prime256v1 (1 2 840 10045 3 1 7)
         :         }
  214  66:       BIT STRING
         :         04 57 E5 AE B1 73 DF D3 AC BB 93 B8 81 FF 12 AE
         :         EE E6 53 AC CE 55 53 F6 34 0E CC 2E E3 63 25 0B
         :         DF 98 E2 F3 5C 60 36 96 C0 D5 18 14 70 E5 7F 9F
         :         D5 4B 45 18 E5 B0 6C D5 5C F8 96 8F 87 70 A3 E4
         :         C7
         :       }
  282 157:     [3] {
  285 154:       SEQUENCE {
  288   9:         SEQUENCE {
  290   3:           OBJECT IDENTIFIER basicConstraints (2 5 29 19)
  295   2:           OCTET STRING, encapsulates {
  297   0:             SEQUENCE {}
         :             }
         :           }
  299  29:         SEQUENCE {
  301   3:           OBJECT IDENTIFIER subjectKeyIdentifier (2 5 29 14)
  306  22:           OCTET STRING, encapsulates {
  308  20:             OCTET STRING
         :              7A 00 5F 86 64 FC E0 5D E5 11 10 3B B2 E6 3B C4
         :              26 3F CF E2
         :             }
         :           }
  330 110:         SEQUENCE {
  332   3:          OBJECT IDENTIFIER authorityKeyIdentifier (2 5 29 35)
  337 103:          OCTET STRING, encapsulates {
  339 101:             SEQUENCE {






Santesson & Tschofenig       Standards Track                   [Page 14]
   __________________________________________________________________


RFC 7924            TLS Cached Information Extension           July 2016


  341  20:               [0]
         :               9D 6D 20 24 49 01 3F 2B CB 78 B5 19 BC 7E 24
         :               C9 DB FB 36 7C
  363  66:               [1] {
  365  64:                 [4] {
  367  62:                   SEQUENCE {
  369  11:                     SET {
  371   9:                      SEQUENCE {
  373   3:                       OBJECT IDENTIFIER countryName (2 5 4 6)
  378   2:                       PrintableString 'NL'
         :                       }
         :                      }
  382  17:                     SET {
  384  15:                      SEQUENCE {
  386   3:                        OBJECT IDENTIFIER organizationName
         :                               (2 5 4 10)
  391   8:                        PrintableString 'PolarSSL'
         :                        }
         :                      }
  401  28:                     SET {
  403  26:                      SEQUENCE {
  405   3:                       OBJECT IDENTIFIER commonName (2 5 4 3)
  410  19:                       PrintableString 'Polarssl Test EC CA'
         :                        }
         :                      }
         :                     }
         :                   }
         :                 }
  431   9:               [2] 00 C1 43 E2 7E 62 43 CC E8
         :               }
         :             }
         :           }
         :         }
         :       }
         :     }
  442  10:   SEQUENCE {
  444   8:     OBJECT IDENTIFIER ecdsaWithSHA256 (1 2 840 10045 4 3 2)
         :     }
  454 104:   BIT STRING, encapsulates {
  457 101:     SEQUENCE {
  459  48:       INTEGER
         :         4A 65 0D 7B 20 83 A2 99 B9 A8 0F FC 8D EE 8F 3D
         :         BB 70 4C 96 03 AC 8E 78 70 DD F2 0E A0 B2 16 CB
         :         65 8E 1A C9 3F 2C 61 7E F8 3C EF AD 1C EE 36 20







Santesson & Tschofenig       Standards Track                   [Page 15]
   __________________________________________________________________


RFC 7924            TLS Cached Information Extension           July 2016


  509  49:       INTEGER
         :         00 9D F2 27 A6 D5 74 B8 24 AE E1 6A 3F 31 A1 CA
         :         54 2F 08 D0 8D EE 4F 0C 61 DF 77 78 7D B4 FD FC
         :         42 49 EE E5 B2 6A C2 CD 26 77 62 8E 28 7C 9E 57
         :         45
         :       }
         :     }
         :   }

                Figure 5: ASN.1-Based Certificate: Example

   To include the certificate shown in Figure 5 in a TLS/DTLS
   Certificate message, it is prepended with a message header.  This
   Certificate message header in our example is 0b 00 02 36 00 02 33 00
   02 00 02 30, which indicates:

   Message Type:  0b -- 1-byte type field indicating a Certificate
      message

   Length:  00 02 36 -- 3-byte length field indicating a 566-byte
      payload

   Certificates Length:  00 02 33 -- 3-byte length field indicating 563
      bytes for the entire certificates_list structure, which may
      contain multiple certificates.  In our example, only one
      certificate is included.

   Certificate Length:  00 02 30 -- 3-byte length field indicating 560
      bytes of the actual certificate following immediately afterwards.
      In our example, this is the certificate content with 30 82 02 ....
      9E 57 45 shown in Figure 6.




















Santesson & Tschofenig       Standards Track                   [Page 16]
   __________________________________________________________________


RFC 7924            TLS Cached Information Extension           July 2016


   The hex encoding of the ASN.1-encoded certificate payload shown in
   Figure 5 leads to the following encoding.

             30 82 02 2C 30 82 01 B2  A0 03 02 01 02 02 01 0D
             30 0A 06 08 2A 86 48 CE  3D 04 03 02 30 3E 31 0B
             30 09 06 03 55 04 06 13  02 4E 4C 31 11 30 0F 06
             03 55 04 0A 13 08 50 6F  6C 61 72 53 53 4C 31 1C
             30 1A 06 03 55 04 03 13  13 50 6F 6C 61 72 73 73
             6C 20 54 65 73 74 20 45  43 20 43 41 30 1E 17 0D
             31 33 30 39 32 34 31 35  35 32 30 34 5A 17 0D 32
             33 30 39 32 32 31 35 35  32 30 34 5A 30 41 31 0B
             30 09 06 03 55 04 06 13  02 4E 4C 31 11 30 0F 06
             03 55 04 0A 13 08 50 6F  6C 61 72 53 53 4C 31 1F
             30 1D 06 03 55 04 03 13  16 50 6F 6C 61 72 53 53
             4C 20 54 65 73 74 20 43  6C 69 65 6E 74 20 32 30
             59 30 13 06 07 2A 86 48  CE 3D 02 01 06 08 2A 86
             48 CE 3D 03 01 07 03 42  00 04 57 E5 AE B1 73 DF
             D3 AC BB 93 B8 81 FF 12  AE EE E6 53 AC CE 55 53
             F6 34 0E CC 2E E3 63 25  0B DF 98 E2 F3 5C 60 36
             96 C0 D5 18 14 70 E5 7F  9F D5 4B 45 18 E5 B0 6C
             D5 5C F8 96 8F 87 70 A3  E4 C7 A3 81 9D 30 81 9A
             30 09 06 03 55 1D 13 04  02 30 00 30 1D 06 03 55
             1D 0E 04 16 04 14 7A 00  5F 86 64 FC E0 5D E5 11
             10 3B B2 E6 3B C4 26 3F  CF E2 30 6E 06 03 55 1D
             23 04 67 30 65 80 14 9D  6D 20 24 49 01 3F 2B CB
             78 B5 19 BC 7E 24 C9 DB  FB 36 7C A1 42 A4 40 30
             3E 31 0B 30 09 06 03 55  04 06 13 02 4E 4C 31 11
             30 0F 06 03 55 04 0A 13  08 50 6F 6C 61 72 53 53
             4C 31 1C 30 1A 06 03 55  04 03 13 13 50 6F 6C 61
             72 73 73 6C 20 54 65 73  74 20 45 43 20 43 41 82
             09 00 C1 43 E2 7E 62 43  CC E8 30 0A 06 08 2A 86
             48 CE 3D 04 03 02 03 68  00 30 65 02 30 4A 65 0D
             7B 20 83 A2 99 B9 A8 0F  FC 8D EE 8F 3D BB 70 4C
             96 03 AC 8E 78 70 DD F2  0E A0 B2 16 CB 65 8E 1A
             C9 3F 2C 61 7E F8 3C EF  AD 1C EE 36 20 02 31 00
             9D F2 27 A6 D5 74 B8 24  AE E1 6A 3F 31 A1 CA 54
             2F 08 D0 8D EE 4F 0C 61  DF 77 78 7D B4 FD FC 42
             49 EE E5 B2 6A C2 CD 26  77 62 8E 28 7C 9E 57 45

             Figure 6: Hex Encoding of the Example Certificate

   Applying the SHA-256 hash function to the Certificate message, which
   starts with 0b 00 02 and ends with 9E 57 45, produces
   0x086eefb4859adfe977defac494fff6b73033b4ce1f86b8f2a9fc0c6bf98605af.







Santesson & Tschofenig       Standards Track                   [Page 17]
   __________________________________________________________________


RFC 7924            TLS Cached Information Extension           July 2016


Acknowledgments

   We would like to thank the following persons for your detailed
   document reviews:

   o  Paul Wouters and Nikos Mavrogiannopoulos (December 2011)

   o  Rob Stradling (February 2012)

   o  Ondrej Mikle (March 2012)

   o  Ilari Liusvaara, Adam Langley, and Eric Rescorla (July 2014)

   o  Sean Turner (August 2014)

   o  Martin Thomson (August 2015)

   o  Jouni Korhonen (November 2015)

   o  Dave Garrett (December 2015)

   o  Matt Miller (December 2015)

   o  Anirudh Ramachandran (March 2016)

   We would also to thank Martin Thomson, Karthikeyan Bhargavan, Sankalp
   Bagaria, and Eric Rescorla for their feedback regarding the
   fingerprint calculation.

   Finally, we would like to thank the TLS working group chairs, Sean
   Turner and Joe Salowey, as well as the responsible Security Area
   Director, Stephen Farrell, for their support and their reviews.



















Santesson & Tschofenig       Standards Track                   [Page 18]
   __________________________________________________________________


RFC 7924            TLS Cached Information Extension           July 2016


Authors' Addresses

   Stefan Santesson
   3xA Security AB
   Forskningsbyn Ideon
   Lund  223 70
   Sweden

   Email: sts@aaa-sec.com


   Hannes Tschofenig
   ARM Ltd.
   Hall in Tirol  6060
   Austria

   Email: Hannes.tschofenig@gmx.net
   URI:   http://www.tschofenig.priv.at

































Santesson & Tschofenig       Standards Track                   [Page 19]


   Html markup produced by rfcmarkup 1.129c, available from
   https://tools.ietf.org/tools/rfcmarkup/
   [Docs] [txt|pdf] [draft-ietf-ipse...] [Tracker] [Diff1] [Diff2]
   [Errata]
   Updated by: 6151 INFORMATIONAL
   Errata Exist
Network Working Group                                       H. Krawczyk
Request for Comments: 2104                                          IBM
Category: Informational                                      M. Bellare
                                                                   UCSD
                                                             R. Canetti
                                                                    IBM
                                                          February 1997


             HMAC: Keyed-Hashing for Message Authentication

Status of This Memo

   This memo provides information for the Internet community.  This memo
   does not specify an Internet standard of any kind.  Distribution of
   this memo is unlimited.

Abstract

   This document describes HMAC, a mechanism for message authentication
   using cryptographic hash functions. HMAC can be used with any
   iterative cryptographic hash function, e.g., MD5, SHA-1, in
   combination with a secret shared key.  The cryptographic strength of
   HMAC depends on the properties of the underlying hash function.

1. Introduction

   Providing a way to check the integrity of information transmitted
   over or stored in an unreliable medium is a prime necessity in the
   world of open computing and communications. Mechanisms that provide
   such integrity check based on a secret key are usually called
   "message authentication codes" (MAC). Typically, message
   authentication codes are used between two parties that share a secret
   key in order to validate information transmitted between these
   parties. In this document we present such a MAC mechanism based on
   cryptographic hash functions. This mechanism, called HMAC, is based
   on work by the authors [BCK1] where the construction is presented and
   cryptographically analyzed. We refer to that work for the details on
   the rationale and security analysis of HMAC, and its comparison to
   other keyed-hash methods.











Krawczyk, et. al.            Informational                      [Page 1]
   __________________________________________________________________


RFC 2104                          HMAC                     February 1997


   HMAC can be used in combination with any iterated cryptographic hash
   function. MD5 and SHA-1 are examples of such hash functions. HMAC
   also uses a secret key for calculation and verification of the
   message authentication values. The main goals behind this
   construction are

   * To use, without modifications, available hash functions.
     In particular, hash functions that perform well in software,
     and for which code is freely and widely available.

   * To preserve the original performance of the hash function without
     incurring a significant degradation.

   * To use and handle keys in a simple way.

   * To have a well understood cryptographic analysis of the strength of
     the authentication mechanism based on reasonable assumptions on the
     underlying hash function.

   * To allow for easy replaceability of the underlying hash function in
     case that faster or more secure hash functions are found or
     required.

   This document specifies HMAC using a generic cryptographic hash
   function (denoted by H). Specific instantiations of HMAC need to
   define a particular hash function. Current candidates for such hash
   functions include SHA-1 [SHA], MD5 [MD5], RIPEMD-128/160 [RIPEMD].
   These different realizations of HMAC will be denoted by HMAC-SHA1,
   HMAC-MD5, HMAC-RIPEMD, etc.

   Note: To the date of writing of this document MD5 and SHA-1 are the
   most widely used cryptographic hash functions. MD5 has been recently
   shown to be vulnerable to collision search attacks [Dobb].  This
   attack and other currently known weaknesses of MD5 do not compromise
   the use of MD5 within HMAC as specified in this document (see
   [Dobb]); however, SHA-1 appears to be a cryptographically stronger
   function. To this date, MD5 can be considered for use in HMAC for
   applications where the superior performance of MD5 is critical.   In
   any case, implementers and users need to be aware of possible
   cryptanalytic developments regarding any of these cryptographic hash
   functions, and the eventual need to replace the underlying hash
   function. (See section 6 for more information on the security of
   HMAC.)








Krawczyk, et. al.            Informational                      [Page 2]
   __________________________________________________________________


RFC 2104                          HMAC                     February 1997


2. Definition of HMAC

   The definition of HMAC requires a cryptographic hash function, which
   we denote by H, and a secret key K. We assume H to be a cryptographic
   hash function where data is hashed by iterating a basic compression
   function on blocks of data.   We denote by B the byte-length of such
   blocks (B=64 for all the above mentioned examples of hash functions),
   and by L the byte-length of hash outputs (L=16 for MD5, L=20 for
   SHA-1).  The authentication key K can be of any length up to B, the
   block length of the hash function.  Applications that use keys longer
   than B bytes will first hash the key using H and then use the
   resultant L byte string as the actual key to HMAC. In any case the
   minimal recommended length for K is L bytes (as the hash output
   length). See section 3 for more information on keys.

   We define two fixed and different strings ipad and opad as follows
   (the 'i' and 'o' are mnemonics for inner and outer):

                   ipad = the byte 0x36 repeated B times
                  opad = the byte 0x5C repeated B times.

   To compute HMAC over the data `text' we perform

                    H(K XOR opad, H(K XOR ipad, text))

   Namely,

    (1) append zeros to the end of K to create a B byte string
        (e.g., if K is of length 20 bytes and B=64, then K will be
         appended with 44 zero bytes 0x00)
    (2) XOR (bitwise exclusive-OR) the B byte string computed in step
        (1) with ipad
    (3) append the stream of data 'text' to the B byte string resulting
        from step (2)
    (4) apply H to the stream generated in step (3)
    (5) XOR (bitwise exclusive-OR) the B byte string computed in
        step (1) with opad
    (6) append the H result from step (4) to the B byte string
        resulting from step (5)
    (7) apply H to the stream generated in step (6) and output
        the result

   For illustration purposes, sample code based on MD5 is provided as an
   appendix.







Krawczyk, et. al.            Informational                      [Page 3]
   __________________________________________________________________


RFC 2104                          HMAC                     February 1997


3. Keys

   The key for HMAC can be of any length (keys longer than B bytes are
   first hashed using H).  However, less than L bytes is strongly
   discouraged as it would decrease the security strength of the
   function.  Keys longer than L bytes are acceptable but the extra
   length would not significantly increase the function strength. (A
   longer key may be advisable if the randomness of the key is
   considered weak.)

   Keys need to be chosen at random (or using a cryptographically strong
   pseudo-random generator seeded with a random seed), and periodically
   refreshed.  (Current attacks do not indicate a specific recommended
   frequency for key changes as these attacks are practically
   infeasible.  However, periodic key refreshment is a fundamental
   security practice that helps against potential weaknesses of the
   function and keys, and limits the damage of an exposed key.)

4. Implementation Note

   HMAC is defined in such a way that the underlying hash function H can
   be used with no modification to its code. In particular, it uses the
   function H with the pre-defined initial value IV (a fixed value
   specified by each iterative hash function to initialize its
   compression function).  However, if desired, a performance
   improvement can be achieved at the cost of (possibly) modifying the
   code of H to support variable IVs.

   The idea is that the intermediate results of the compression function
   on the B-byte blocks (K XOR ipad) and (K XOR opad) can be precomputed
   only once at the time of generation of the key K, or before its first
   use. These intermediate results are stored and then used to
   initialize the IV of H each time that a message needs to be
   authenticated.  This method saves, for each authenticated message,
   the application of the compression function of H on two B-byte blocks
   (i.e., on (K XOR ipad) and (K XOR opad)). Such a savings may be
   significant when authenticating short streams of data.  We stress
   that the stored intermediate values need to be treated and protected
   the same as secret keys.

   Choosing to implement HMAC in the above way is a decision of the
   local implementation and has no effect on inter-operability.









Krawczyk, et. al.            Informational                      [Page 4]
   __________________________________________________________________


RFC 2104                          HMAC                     February 1997


5. Truncated output

   A well-known practice with message authentication codes is to
   truncate the output of the MAC and output only part of the bits
   (e.g., [MM, ANSI]).  Preneel and van Oorschot [PV] show some
   analytical advantages of truncating the output of hash-based MAC
   functions. The results in this area are not absolute as for the
   overall security advantages of truncation. It has advantages (less
   information on the hash result available to an attacker) and
   disadvantages (less bits to predict for the attacker).  Applications
   of HMAC can choose to truncate the output of HMAC by outputting the t
   leftmost bits of the HMAC computation for some parameter t (namely,
   the computation is carried in the normal way as defined in section 2
   above but the end result is truncated to t bits). We recommend that
   the output length t be not less than half the length of the hash
   output (to match the birthday attack bound) and not less than 80 bits
   (a suitable lower bound on the number of bits that need to be
   predicted by an attacker).  We propose denoting a realization of HMAC
   that uses a hash function H with t bits of output as HMAC-H-t. For
   example, HMAC-SHA1-80 denotes HMAC computed using the SHA-1 function
   and with the output truncated to 80 bits.  (If the parameter t is not
   specified, e.g. HMAC-MD5, then it is assumed that all the bits of the
   hash are output.)

6. Security

   The security of the message authentication mechanism presented here
   depends on cryptographic properties of the hash function H: the
   resistance to collision finding (limited to the case where the
   initial value is secret and random, and where the output of the
   function is not explicitly available to the attacker), and the
   message authentication property of the compression function of H when
   applied to single blocks (in HMAC these blocks are partially unknown
   to an attacker as they contain the result of the inner H computation
   and, in particular, cannot be fully chosen by the attacker).

   These properties, and actually stronger ones, are commonly assumed
   for hash functions of the kind used with HMAC. In particular, a hash
   function for which the above properties do not hold would become
   unsuitable for most (probably, all) cryptographic applications,
   including alternative message authentication schemes based on such
   functions.  (For a complete analysis and rationale of the HMAC
   function the reader is referred to [BCK1].)








Krawczyk, et. al.            Informational                      [Page 5]
   __________________________________________________________________


RFC 2104                          HMAC                     February 1997


   Given the limited confidence gained so far as for the cryptographic
   strength of candidate hash functions, it is important to observe the
   following two properties of the HMAC construction and its secure use
   for message authentication:

   1. The construction is independent of the details of the particular
   hash function H in use and then the latter can be replaced by any
   other secure (iterative) cryptographic hash function.

   2. Message authentication, as opposed to encryption, has a
   "transient" effect. A published breaking of a message authentication
   scheme would lead to the replacement of that scheme, but would have
   no adversarial effect on information authenticated in the past.  This
   is in sharp contrast with encryption, where information encrypted
   today may suffer from exposure in the future if, and when, the
   encryption algorithm is broken.

   The strongest attack known against HMAC is based on the frequency of
   collisions for the hash function H ("birthday attack") [PV,BCK2], and
   is totally impractical for minimally reasonable hash functions.

   As an example, if we consider a hash function like MD5 where the
   output length equals L=16 bytes (128 bits) the attacker needs to
   acquire the correct message authentication tags computed (with the
   _same_ secret key K!) on about 2**64 known plaintexts.  This would
   require the processing of at least 2**64 blocks under H, an
   impossible task in any realistic scenario (for a block length of 64
   bytes this would take 250,000 years in a continuous 1Gbps link, and
   without changing the secret key K during all this time).  This attack
   could become realistic only if serious flaws in the collision
   behavior of the function H are discovered (e.g.  collisions found
   after 2**30 messages). Such a discovery would determine the immediate
   replacement of the function H (the effects of such failure would be
   far more severe for the traditional uses of H in the context of
   digital signatures, public key certificates, etc.).

   Note: this attack needs to be strongly contrasted with regular
   collision attacks on cryptographic hash functions where no secret key
   is involved and where 2**64 off-line parallelizable (!) operations
   suffice to find collisions.  The latter attack is approaching
   feasibility [VW] while the birthday attack on HMAC is totally
   impractical.  (In the above examples, if one uses a hash function
   with, say, 160 bit of output then 2**64 should be replaced by 2**80.)








Krawczyk, et. al.            Informational                      [Page 6]
   __________________________________________________________________


RFC 2104                          HMAC                     February 1997


   A correct implementation of the above construction, the choice of
   random (or cryptographically pseudorandom) keys, a secure key
   exchange mechanism, frequent key refreshments, and good secrecy
   protection of keys are all essential ingredients for the security of
   the integrity verification mechanism provided by HMAC.














































Krawczyk, et. al.            Informational                      [Page 7]
   __________________________________________________________________


RFC 2104                          HMAC                     February 1997


Appendix -- Sample Code

   For the sake of illustration we provide the following sample code for
   the implementation of HMAC-MD5 as well as some corresponding test
   vectors (the code is based on MD5 code as described in [MD5]).

/*
** Function: hmac_md5
*/

void
hmac_md5(text, text_len, key, key_len, digest)
unsigned char*  text;                /* pointer to data stream */
int             text_len;            /* length of data stream */
unsigned char*  key;                 /* pointer to authentication key */
int             key_len;             /* length of authentication key */
caddr_t         digest;              /* caller digest to be filled in */

{
        MD5_CTX context;
        unsigned char k_ipad[65];    /* inner padding -
                                      * key XORd with ipad
                                      */
        unsigned char k_opad[65];    /* outer padding -
                                      * key XORd with opad
                                      */
        unsigned char tk[16];
        int i;
        /* if key is longer than 64 bytes reset it to key=MD5(key) */
        if (key_len > 64) {

                MD5_CTX      tctx;

                MD5Init(&tctx);
                MD5Update(&tctx, key, key_len);
                MD5Final(tk, &tctx);

                key = tk;
                key_len = 16;
        }

        /*
         * the HMAC_MD5 transform looks like:
         *
         * MD5(K XOR opad, MD5(K XOR ipad, text))
         *
         * where K is an n byte key
         * ipad is the byte 0x36 repeated 64 times



Krawczyk, et. al.            Informational                      [Page 8]
   __________________________________________________________________


RFC 2104                          HMAC                     February 1997


         * opad is the byte 0x5c repeated 64 times
         * and text is the data being protected
         */

        /* start out by storing key in pads */
        bzero( k_ipad, sizeof k_ipad);
        bzero( k_opad, sizeof k_opad);
        bcopy( key, k_ipad, key_len);
        bcopy( key, k_opad, key_len);

        /* XOR key with ipad and opad values */
        for (i=0; i<64; i++) {
                k_ipad[i] ^= 0x36;
                k_opad[i] ^= 0x5c;
        }
        /*
         * perform inner MD5
         */
        MD5Init(&context);                   /* init context for 1st
                                              * pass */
        MD5Update(&context, k_ipad, 64)      /* start with inner pad */
        MD5Update(&context, text, text_len); /* then text of datagram */
        MD5Final(digest, &context);          /* finish up 1st pass */
        /*
         * perform outer MD5
         */
        MD5Init(&context);                   /* init context for 2nd
                                              * pass */
        MD5Update(&context, k_opad, 64);     /* start with outer pad */
        MD5Update(&context, digest, 16);     /* then results of 1st
                                              * hash */
        MD5Final(digest, &context);          /* finish up 2nd pass */
}

Test Vectors (Trailing '\0' of a character string not included in test):

  key =         0x0b0b0b0b0b0b0b0b0b0b0b0b0b0b0b0b
  key_len =     16 bytes
  data =        "Hi There"
  data_len =    8  bytes
  digest =      0x9294727a3638bb1c13f48ef8158bfc9d

  key =         "Jefe"
  data =        "what do ya want for nothing?"
  data_len =    28 bytes
  digest =      0x750c783e6ab0b503eaa86e310a5db738

  key =         0xAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAA



Krawczyk, et. al.            Informational                      [Page 9]
   __________________________________________________________________


RFC 2104                          HMAC                     February 1997


  key_len       16 bytes
  data =        0xDDDDDDDDDDDDDDDDDDDD...
                ..DDDDDDDDDDDDDDDDDDDD...
                ..DDDDDDDDDDDDDDDDDDDD...
                ..DDDDDDDDDDDDDDDDDDDD...
                ..DDDDDDDDDDDDDDDDDDDD
  data_len =    50 bytes
  digest =      0x56be34521d144c88dbb8c733f0e8b3f6

Acknowledgments

   Pau-Chen Cheng, Jeff Kraemer, and Michael Oehler, have provided
   useful comments on early drafts, and ran the first interoperability
   tests of this specification. Jeff and Pau-Chen kindly provided the
   sample code and test vectors that appear in the appendix.  Burt
   Kaliski, Bart Preneel, Matt Robshaw, Adi Shamir, and Paul van
   Oorschot have provided useful comments and suggestions during the
   investigation of the HMAC construction.

References

   [ANSI]  ANSI X9.9, "American National Standard for Financial
           Institution Message Authentication (Wholesale)," American
           Bankers Association, 1981.   Revised 1986.

   [Atk]   Atkinson, R., "IP Authentication Header", RFC 1826, August
           1995.

   [BCK1]  M. Bellare, R. Canetti, and H. Krawczyk,
           "Keyed Hash Functions and Message Authentication",
           Proceedings of Crypto'96, LNCS 1109, pp. 1-15.
           (http://www.research.ibm.com/security/keyed-md5.html)

   [BCK2]  M. Bellare, R. Canetti, and H. Krawczyk,
           "Pseudorandom Functions Revisited: The Cascade Construction",
           Proceedings of FOCS'96.

   [Dobb]  H. Dobbertin, "The Status of MD5  After a Recent Attack",
           RSA Labs' CryptoBytes, Vol. 2 No. 2, Summer 1996.
           http://www.rsa.com/rsalabs/pubs/cryptobytes.html

   [PV]    B. Preneel and P. van Oorschot, "Building fast MACs from hash
           functions", Advances in Cryptology -- CRYPTO'95 Proceedings,
           Lecture Notes in Computer Science, Springer-Verlag Vol.963,
           1995, pp. 1-14.

   [MD5]   Rivest, R., "The MD5 Message-Digest Algorithm",
           RFC 1321, April 1992.



Krawczyk, et. al.            Informational                     [Page 10]
   __________________________________________________________________


RFC 2104                          HMAC                     February 1997


   [MM]    Meyer, S. and Matyas, S.M., Cryptography, New York Wiley,
           1982.

   [RIPEMD] H. Dobbertin, A. Bosselaers, and B. Preneel, "RIPEMD-160: A
            strengthened version of RIPEMD", Fast Software Encryption,
            LNCS Vol 1039, pp. 71-82.
            ftp://ftp.esat.kuleuven.ac.be/pub/COSIC/bosselae/ripemd/.

   [SHA]   NIST, FIPS PUB 180-1: Secure Hash Standard, April 1995.

   [Tsu]   G. Tsudik, "Message authentication with one-way hash
           functions", In Proceedings of Infocom'92, May 1992.
           (Also in "Access Control and Policy Enforcement in
            Internetworks", Ph.D. Dissertation, Computer Science
            Department, University of Southern California, April 1991.)

   [VW]    P. van Oorschot and M. Wiener, "Parallel Collision
           Search with Applications to Hash Functions and Discrete
           Logarithms", Proceedings of the 2nd ACM Conf. Computer and
           Communications Security, Fairfax, VA, November 1994.

Authors' Addresses

   Hugo Krawczyk
   IBM T.J. Watson Research Center
   P.O.Box 704
   Yorktown Heights, NY 10598

   EMail: hugo@watson.ibm.com

   Mihir Bellare
   Dept of Computer Science and Engineering
   Mail Code 0114
   University of California at San Diego
   9500 Gilman Drive
   La Jolla, CA 92093

   EMail: mihir@cs.ucsd.edu

   Ran Canetti
   IBM T.J. Watson Research Center
   P.O.Box 704
   Yorktown Heights, NY 10598

   EMail: canetti@watson.ibm.com






Krawczyk, et. al.            Informational                     [Page 11]


   Html markup produced by rfcmarkup 1.129c, available from
   https://tools.ietf.org/tools/rfcmarkup/
